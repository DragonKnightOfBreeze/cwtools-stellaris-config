# scripted effects

alias[effect:<scripted_effect>] = bool

# effects

### The scripted effect will draw the value of the right clause via $left_clause$.
alias[effect:<scripted_effect>] = {
	## cardinality = 1..inf
	$parameter = scalar
	## cardinality = 1..inf
	$parameter = scope_field
}

### Creates a starbase in orbit of the star of the scoped galactic object
## scopes = { planet galactic_object }
alias[effect:create_starbase] = {
	## cardinality = 0..1
	owner = scope_group[target_country]
	## cardinality = 1..1
	size = <ship_size.starbase>
	## cardinality = 0..100
	module = <starbase_module>
	## cardinality = 0..100
	building = <starbase_building>
	## cardinality = 0..1
	## push_scope = starbase
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Prevents enclosed effects from being displayed in tooltip
## scopes = any
alias[effect:hidden_effect] = { alias_name[effect] = alias_match_left[effect] }

### Executes enclosed effects if limit criteria are met
## scopes = any
alias[effect:if] = {
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
	alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met
### if = { limit = { <triggers> } <effects> }
## scopes = any
alias[effect:else_if] = {
	## severity = info
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
	alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met
### if = { limit = { <triggers> } <effects> }
## scopes = any
alias[effect:else] = {
	alias_name[effect] = alias_match_left[effect]
}

### Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain
## scopes = any
alias[effect:save_event_target_as] = value_set[event_target]
### Saves the current scope as an arbitrarily-named target to be referenced later, accessible globally until cleared
## scopes = any
alias[effect:save_global_event_target_as] = value_set[global_event_target]

### Fires a ship event for the scoped ship, with optional DAYS and RANDOM delay
## scopes = { ship }
alias[effect:ship_event] = {
	id = <event.scopeless>
	id = <event.ship>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a country event for the scoped country, with optional DAYS and RANDOM delay
## scopes = { country }
alias[effect:country_event] = {
	id = <event.scopeless>
	id = <event.country>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a first contact event for the scoped first contact site, with optional DAYS and RANDOM delay
## scopes = { first_contact }
alias[effect:first_contact_event] = {
	id = <event.scopeless>
	id = <event.first_contact>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires an observer event for all observers.
## scopes = any
alias[effect:observer_event] = {
	id = <event.scopeless>
	id = <event.observer>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a pop faction event for the scoped pop faction, with optional DAYS and RANDOM delay
## scopes = { pop_faction }
alias[effect:pop_faction_event] = {
	id = <event.scopeless>
	id = <event.pop_faction>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a pop event for the scoped pop, with optional DAYS and RANDOM delay
## scopes = { pop }
alias[effect:pop_event] = {
	id = <event.scopeless>
	id = <event.pop>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a fleet event for the scoped fleet, with optional DAYS and RANDOM delay
## scopes = { fleet }
alias[effect:fleet_event] = {
	id = <event.scopeless>
	id = <event.fleet>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a planet event for the scoped planet, with optional DAYS and RANDOM delay
## scopes = { planet }
alias[effect:planet_event] = {
	id = <event.scopeless>
	id = <event.planet>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a leader event for the scoped leader, with optional DAYS and RANDOM delay
## scopes = { leader }
alias[effect:leader_event] = {
	id = <event.scopeless>
	id = <event.leader>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a situation event for the scoped situation, with optional DAYS and RANDOM delay
## scopes = { situation }
alias[effect:situation_event] = {
	id = <event.scopeless>
	id = <event.situation>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires an agreement event for the scoped agreement, with optional DAYS and RANDOM delay
## scopes = { agreement }
alias[effect:agreement_event] = {
	id = <event.scopeless>
	id = <event.agreement>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a starbase event for the scoped starbase, with optional DAYS and RANDOM delay
## scopes = { starbase }
alias[effect:starbase_event] = {
	id = <event.scopeless>
	id = <event.starbase>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires a system event for the scoped system, with optional DAYS and RANDOM delay
## scopes = { galactic_object }
alias[effect:system_event] = {
	id = <event.scopeless>
	id = <event.system>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Fires an espionage operation event for the scoped espionage operation, with optional DAYS and RANDOM delay
## scopes = { espionage_operation }
alias[effect:espionage_operation_event] = {
	id = <event.scopeless>
	id = <event.espionage_operation>
	## cardinality = 0..1
	days = int
	## cardinality = 0..1
	random = int
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Adds a specific modifier to the scoped object for a set duration
## scopes = { megastructure planet country ship pop fleet galactic_object pop_faction federation spy_network espionage_operation }
alias[effect:add_modifier] = {
	modifier = <static_modifier>
	# severity = info
	## cardinality = 0..1
	enum[days_months_years] = int
	## cardinality = 0..1
	mult = value_field
	## cardinality = 0..1
	multiplier = value_field
	## cardinality = 0..1
	time_multiplier = value_field
	## cardinality = 0..1
	clear_on_owner_change = yes
}

### Displays a specific localization string in tooltip
## scopes = any
alias[effect:custom_tooltip] = localisation

### Adds a specific opinion modifier for the scoped country towards target country
## scopes = { country }
alias[effect:add_opinion_modifier] = {
	who = scope_group[target_country]
	modifier = <opinion_modifier>
}
### Removes a specific opinion modifier towards target country or any contry from the scoped country
## scopes = { country }
alias[effect:remove_opinion_modifier] = {
	who = scope_group[target_country]
	modifier = <opinion_modifier>
}

### Removes a specific modifier from the scope object
## scopes = { megastructure planet country ship pop fleet galactic_object pop_faction federation spy_network espionage_operation }
alias[effect:remove_modifier] = <static_modifier>

# flags

### Sets an arbitrarily-named flag on the scoped country
## scopes = { country }
alias[effect:set_country_flag] = value_set[country_flag]
### Sets an arbitrarily-named flag on the scoped planet
## scopes = { planet }
alias[effect:set_planet_flag] = value_set[planet_flag]
### Sets an arbitrarily-named flag on the scoped pop's faction/pop faction
## scopes = { pop pop_faction }
alias[effect:set_pop_faction_flag] = value_set[pop_faction_flag]
### Sets an arbitrarily-named flag on the scoped system
## scopes = { galactic_object }
alias[effect:set_star_flag] = value_set[star_flag]
### Sets an arbitrarily-named flag on the scoped species
## scopes = { species }
alias[effect:set_species_flag] = value_set[species_flag]
### Sets an arbitrarily-named flag on the scoped pop
## scopes = { pop }
alias[effect:set_pop_flag] = value_set[pop_flag]
### Sets an arbitrarily-named flag on the scoped fleet
## scopes = { fleet }
alias[effect:set_fleet_flag] = value_set[fleet_flag]
### Sets an arbitrarily-named flag on the scoped ship
## scopes = { ship }
alias[effect:set_ship_flag] = value_set[ship_flag]
### Sets an arbitrarily-named global flag
## scopes = any
alias[effect:set_global_flag] = value_set[global_flag]
### Sets an arbitrarily-named flag on the scoped leader
## scopes = { leader }
alias[effect:set_leader_flag] = value_set[leader_flag]
### Sets an arbitrarily-named flag on the scoped ambient object
## scopes = { ambient_object }
alias[effect:set_ambient_object_flag] = value_set[ambient_object_flag]
### Sets an arbitrarily-named flag on the scoped mega structure
## scopes = { megastructure }
alias[effect:set_megastructure_flag] = value_set[megastructure_flag]
### Sets an arbitrarily-named flag on the scoped deposit
## scopes = { deposit }
alias[effect:set_deposit_flag] = value_set[deposit_flag]
### Sets an arbitrarily-named flag on the scoped sector
## scopes = { sector }
alias[effect:set_sector_flag] = value_set[sector_flag]
### Sets an arbitrarily-named flag on the scoped arc site
## scopes = { archaeological_site }
alias[effect:set_archaeology_flag] = value_set[archaeology_flag]
### Sets an arbitrarily-named flag on the scoped starbase
## scopes = { starbase }
alias[effect:set_starbase_flag] = value_set[starbase_flag]
### Sets an arbitrarily-named flag on the scoped spy network
## scopes = { spy_network }
alias[effect:set_spynetwork_flag] = value_set[spynetwork_flag]
### Sets an arbitrarily-named flag on the scoped espionage asset
## scopes = { espionage_asset }
alias[effect:set_espionage_asset_flag] = value_set[espionage_asset_flag]
### Sets an arbitrarily-named flag on the scoped war
## scopes = { war }
alias[effect:set_war_flag] = value_set[war_flag]
### Sets an arbitrarily-named flag on the scoped army
## scopes = { army }
alias[effect:set_army_flag] = value_set[army_flag]
### Sets an arbitrarily-named flag on the scoped situation
## scopes = { situation }
alias[effect:set_situation_flag] = value_set[situation_flag]
### Sets an arbitrarily-named flag on the scoped agreement
## scopes = { agreement }
alias[effect:set_agreement_flag] = value_set[agreement_flag]

### Removes a flag from the scoped country
## scopes = { country }
## severity = warning
alias[effect:remove_country_flag] = value[country_flag]
### Removes a flag from the scoped planet
## scopes = { planet }
## severity = warning
alias[effect:remove_planet_flag] = value[planet_flag]
### Removes a flag from the scoped pop's faction/pop faction
## scopes = { pop pop_faction }
## severity = warning
alias[effect:remove_pop_faction_flag] = value[pop_faction_flag]
### Removes a flag from the scoped system
## scopes = { galactic_object }
## severity = warning
alias[effect:remove_star_flag] = value[star_flag]
### Removes a flag from the scoped species
## scopes = { species }
## severity = warning
alias[effect:remove_species_flag] = value[species_flag]
### Removes a flag from the scoped pop
## scopes = { pop }
## severity = warning
alias[effect:remove_pop_flag] = value[pop_flag]
### Removes a flag from the scoped fleet
## scopes = { fleet }
## severity = warning
alias[effect:remove_fleet_flag] = value[fleet_flag]
### Removes a flag from the scoped ship
## scopes = { ship }
## severity = warning
alias[effect:remove_ship_flag] = value[ship_flag]
### Removes a global flag
## scopes = any
## severity = warning
alias[effect:remove_global_flag] = value[global_flag]
### Removes a flag from the scoped leader
## scopes = { leader }
## severity = warning
alias[effect:remove_leader_flag] = value[leader_flag]
### Removes a flag from the scoped ambient object
## scopes = { ambient_object }
## severity = warning
alias[effect:remove_ambient_object_flag] = value[ambient_object_flag]
### Removes a flag from the scoped mega structure
## scopes = { megastructure }
## severity = warning
alias[effect:remove_megastructure_flag] = value[megastructure_flag]
### Removes a flag from the scoped deposit
## scopes = { deposit }
## severity = warning
alias[effect:remove_deposit_flag] = value[deposit_flag]
### Removes a flag from the scoped sector
## scopes = { sector }
## severity = warning
alias[effect:remove_sector_flag] = value[sector_flag]
### Removes a flag from the scoped arc site
## scopes = { archaeological_site }
## severity = warning
alias[effect:remove_archaeology_flag] = value[archaeology_flag]
### Removes a flag from the scoped starbase
## scopes = { starbase }
## severity = warning
alias[effect:remove_starbase_flag] = value[starbase_flag]
### Removes a flag from the scoped spy network
## scopes = { spy_network }
## severity = warning
alias[effect:remove_spynetwork_flag] = value[spynetwork_flag]
### Removes a flag from the scoped espionage asset
## scopes = { espionage_asset }
## severity = warning
alias[effect:remove_espionage_asset_flag] = value[espionage_asset_flag]
### Removes a flag from the scoped war
## scopes = { war }
## severity = warning
alias[effect:remove_war_flag] = value[war_flag]
### Removes a flag from the scoped army
## scopes = { army }
## severity = warning
alias[effect:remove_army_flag] = value[army_flag]
### Removes a flag from the scoped situation
## scopes = { situation }
## severity = warning
alias[effect:remove_situation_flag] = value[situation_flag]
### Removes a flag from the scoped agreement
## scopes = { agreement }
## severity = warning
alias[effect:remove_agreement_flag] = value[agreement_flag]

### Sets an arbitrarily-named flag on the scoped country for a set duration
## scopes = { country }
alias[effect:set_timed_country_flag] = {
	flag = value_set[country_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped planet for a set duration
## scopes = { planet }
alias[effect:set_timed_planet_flag] = {
	flag = value_set[planet_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped pop faction for a set duration
## scopes = { pop pop_faction }
alias[effect:set_timed_pop_faction_flag] = {
	flag = value_set[pop_faction_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped system for a set duration
## scopes = { galactic_object }
alias[effect:set_timed_star_flag] = {
	flag = value_set[star_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped species for a set duration
## scopes = { species }
alias[effect:set_timed_species_flag] = {
	flag = value_set[species_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped pop for a set duration
## scopes = { pop }
alias[effect:set_timed_pop_flag] = {
	flag = value_set[pop_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped fleet for a set duration
## scopes = { fleet }
alias[effect:set_timed_fleet_flag] = {
	flag = value_set[fleet_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped ship for a set duration
## scopes = { ship }
alias[effect:set_timed_ship_flag] = {
	flag = value_set[ship_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named global flag for a set duration
## scopes = any
alias[effect:set_timed_global_flag] = {
	flag = value_set[global_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped leader for a set duration
## scopes = { leader }
alias[effect:set_timed_leader_flag] = {
	flag = value_set[leader_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped ambient object for a set duration
## scopes = { fleet }
alias[effect:set_timed_ambient_object_flag] = {
	flag = value_set[ambient_object_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped mega structure for a set duration
## scopes = { megastructure }
alias[effect:set_timed_megastructure_flag] = {
	flag = value_set[megastructure_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped deposit for a set duration
## scopes = { deposit }
alias[effect:set_timed_deposit_flag] = {
	flag = value_set[deposit_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped sector for a set duration
## scopes = { sector }
alias[effect:set_timed_sector_flag] = {
	flag = value_set[sector_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped arc site for a set duration
## scopes = { archaeological_site }
alias[effect:set_timed_archaeology_flag] = {
	flag = value_set[archaeology_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped starbase for a set duration
## scopes = { starbase }
alias[effect:set_timed_starbase_flag] = {
	flag = value_set[starbase_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped spy network for a set duration
## scopes = { spy_network }
alias[effect:set_timed_spynetwork_flag] = {
	flag = value_set[spynetwork_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped espionage asset for a set duration
## scopes = { espionage_asset }
alias[effect:set_timed_espionage_asset_flag] = {
	flag = value_set[espionage_asset_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped war for a set duration
## scopes = { war }
alias[effect:set_timed_war_flag] = {
	flag = value_set[war_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped army for a set duration
## scopes = { army }
alias[effect:set_timed_army_flag] = {
	flag = value_set[army_flag]
	enum[days_months_years] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped situation for a set duration
## scopes = { situation }
alias[effect:set_timed_situation_flag] = {
	flag = value_set[situation_flag]
	enum[days_months_years] = int_value_field
}

### Sets an arbitrarily-named flag on the scoped agreement for a set duration
## scopes = { agreement }
alias[effect:set_timed_agreement_flag] = {
	flag = value_set[agreement_flag]
	enum[days_months_years] = int_value_field
}

### Removes a mega structure.
## scopes = any
alias[effect:remove_megastructure] = scope[megastructure]

### Sets a relation flag for the scoped country towards target country
## scopes = { country }
alias[effect:set_relation_flag] = {
	who = scope_group[target_country]
	flag = value_set[relation_flag]
}
### Sets an arbitrarily-named flag for the scoped country towards target country for a set duration
## scopes = { country }
alias[effect:set_timed_relation_flag] = {
	who = scope_group[target_country]
	flag = value_set[relation_flag]
	enum[days_months_years] = int_value_field
}
### Removes a specific relation flag towards target country from the scoped country
## scopes = { country }
## severity = warning
alias[effect:remove_relation_flag] = {
	who = scope_group[target_country]
	flag = value[relation_flag]
}

### Change the scoped country's government authority and/or civics
## scopes = { country }
alias[effect:change_government] = random
### Change the scoped country's government authority and/or civics
## scopes = { country }
alias[effect:change_government] = {
	## cardinality = 0..1
	authority = random
	## cardinality = 0..1
	authority = <authority>
	## cardinality = 0..1
	### random includes starting civics
	civics = random
	## cardinality = 0..1
	civics = {
		## cardinality = 1..4
		civic = <civic_or_origin.civic>
		## cardinality = 1..4
		civic = random
	}
	## cardinality = 0..1
	cooldown = bool
	## cardinality = 0..1
	remove_invalid_civics = yes
}

#ideally, "heir" should only be if type = ruler
### Kills the scoped leader or leader of the scoped country/fleet/ship/planet/army
## scopes = { planet country ship fleet leader army }
alias[effect:kill_leader] = {
	## cardinality = 0..1
	type = enum[leader_classes]
	## cardinality = 0..1
	type = random
	## cardinality = 0..1
	show_notification = bool
	## cardinality = 0..1
	heir = bool
	## cardinality = 0..1
	### default: no; if yes, fires on_leader_fired instead of on_leader_death
	fire = yes
}

### Shifts an empire towards a specific ethic, adjusting afterwards to keep number of ethics points consistent
## scopes = { country }
alias[effect:shift_ethic] = <ethic>
### Adds a specific ethic to the scoped country
## scopes = { country }
alias[effect:country_add_ethic] = <ethic>
### Adds a specific ethic to the scoped country
## scopes = { country }
alias[effect:country_add_ethic] = random
### Removes a specific ethic from the scoped country
## scopes = { country }
alias[effect:country_remove_ethic] = <ethic>
### Instantly destroys the scoped pop
## scopes = { pop }
alias[effect:kill_pop] = yes
# alias[effect:enslave_pop] = bool	#deprecated
### Destroys the colony on the scoped planet
## scopes = { planet }
alias[effect:destroy_colony] = yes
#alias[effect:set_ruined] = bool

### Picks one random set of effects from a list, influenced by relative weight
## scopes = any
alias[effect:random_list] = {
	## cardinality = 1..inf
	int = {
		## cardinality = 0..inf
		alias_name[modifier_rule] = alias_match_left[modifier_rule]
		## cardinality = 0..inf
		alias_name[effect] = alias_match_left[effect]
	}
}

### Picks one random set of effects from a list, influenced by relative weight once per event scope.
### Works like a random list, but the tooltip will only show the option that actually happens.
## scopes = any
alias[effect:locked_random_list] = {
	## cardinality = 1..inf
	int = {
		## cardinality = 0..inf
		alias_name[modifier_rule] = alias_match_left[modifier_rule]
		## cardinality = 0..inf
		alias_name[effect] = alias_match_left[effect]
	}
}

### All enclosed effects may or may not be executed depending on set chance
## scopes = any
alias[effect:random] = {
	chance = int_value_field[1...99]
	## cardinality = 1..inf
	alias_name[effect] = alias_match_left[effect]
}

### Creates a new fleet from empire designs up to specified fraction of naval cap
## scopes = { country }
alias[effect:create_fleet_from_naval_cap] = value_field
### Creates a new fleet from empire designs up to specified fraction of naval cap
## scopes = { country }
alias[effect:create_fleet_from_naval_cap] = {
	fraction = value_field
	ship_owner_type = country
	ship_owner_type = federation
	ship_owner_type = galactic_community
}

### Reduces the hull points of the scoped ship by a specific amount
## scopes = { ship }
alias[effect:reduce_hp] = int_value_field
# ### Reduces the hull points of the scoped ship by a relative amount
# alias[effect:reduce_hp_percent] = value_field[0.0..1.0]
### Reduces the hull points of the scoped ship by a relative amount
## scopes = { ship }
alias[effect:reduce_hp_percent] = int_value_field[0..100]
### Exiles the scoped country/fleet/army/pop faction's leader and saves them with a custom name
## scopes = { country fleet leader army pop_faction }
alias[effect:exile_leader_as] = value_set[exiled_leader]
### Adds a sum of experience points to the scoped leader
## scopes = { leader }
alias[effect:add_experience] = int_value_field
### Sets the gender of the scoped leader
## scopes = { leader }
alias[effect:set_is_female] = bool
### Sets scoped leader as non/recruitable
## scopes = { leader }
alias[effect:recruitable] = bool
### Assigns target leader to the scoped country/fleet/army/pop faction/sector
## scopes = { country fleet army pop_faction sector }
alias[effect:assign_leader] = scope_group[target_leader]
### Unassigns scoped leader from their post or unassigns leader from the scoped planet/ship/fleet/army
## scopes = { ship fleet leader army }
alias[effect:unassign_leader] = scope_group[target_leader]
### Adds claims on target system
## scopes = { galactic_object }
alias[effect:add_claims] = {
	who = scope_group[target_country]
	## cardinality = 0..1
	num_of_claims = int
	## cardinality = 0..1
	show_notification = bool
}

### Instantly sets the owner of the scoped planet/fleet/army/starbase to target country
## scopes = { megastructure planet fleet leader army starbase }
alias[effect:set_owner] = scope_group[target_country]
### Instantly sets the planet/fleet's controller to target country
## scopes = { planet fleet }
alias[effect:set_controller] = scope_group[target_country]
### Sets the fleet/ambient object's location, can be fine-tuned
## scopes = { fleet ambient_object }
alias[effect:set_location] = scope_group[spatial_object]
### Sets the fleet/ambient object's location, can be fine-tuned
## scopes = { fleet ambient_object }
alias[effect:set_location] = {
	target = scope_group[spatial_object]
	## cardinality = 0..1
	distance = float #No variables here atm
	## cardinality = 0..1
	angle = int[0..360]
	## cardinality = 0..1
	angle = random
	## cardinality = 0..1
	direction = in_system
	## cardinality = 0..1
	direction = out_system
}

# variables

### Sets or creates an arbitrarily-named variable with a specific value in the current scope
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:set_variable] = {
	which = value_set[variable]
	value = value_field
}

### Sets a variable to a random value within the specified bounds
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:set_variable_to_random_value] = {
	which = value_set[variable]
	min = value_field
	max = value_field
	rounded = bool
}

#presumably need to check the variable exists first for these, somehow
### Increments a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:change_variable] = {
	which = value_set[variable]
	value = value_field
}

### Decrements a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:subtract_variable] = {
	which = value[variable]
	value = value_field
}

### Multiplies a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:multiply_variable] = {
	which = value[variable]
	value = value_field
}

### Divides a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:divide_variable] = {
	which = value[variable]
	value = value_field
}

### Modulos a previously-set variable by a specific amount i.e. X % Y
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:modulo_variable] = {
	which = value[variable]
	value = value_field
}

### Rounds a previously-set variable to the closest X
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:round_variable_to_closest] = {
	which = value[variable]
	value = value_field
}

### Clears a previously-set variable from the game.
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:clear_variable] = value[variable]


#max should not be less than min...
### Adds a lump sum of a resource to the scoped country, defined as a multiple of the country's monthly income of that resource (clamped to max and min allowed values)
## scopes = { country }
alias[effect:add_monthly_resource_mult] = {
	resource = <resource>
	value = value_field
	## cardinality = 0..1
	min = int
	## cardinality = 0..1
	max = int
}

### Adds a specific trait to the scoped leader
## scopes = { leader }
alias[effect:add_trait] = <trait.leader_trait>
### Adds a specific ruler trait to the scoped leader, even if they are not currently ruler; it becomes active when they become ruler
## scopes = { leader }
## severity = warning
alias[effect:add_ruler_trait] = <trait.leader_trait>
### Removes a specific trait from the scoped leader
## scopes = { leader }
alias[effect:remove_trait] = <trait.leader_trait>
#also, at least one of while and limit should be there
### Repeats enclosed effects while limit criteria are met or until set iteration count is reached
## scopes = any
alias[effect:while] = {
	## cardinality = 0..1
	count = int_value_field
	## cardinality = 0..1
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
	alias_name[effect] = alias_match_left[effect]
}

### Instantly resettles pop
## scopes = any
alias[effect:resettle_pop] = {
	pop = scope[pop]
	## cardinality = 0..1
	planet = scope_group[target_planet]
}

#also, most of these are not used in Vanilla (the first is, I did the cardinality based on it)
### Set citizenship type for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_citizenship_type] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = <citizenship_type>
	## cardinality = 0..1
	cooldown = bool
}

### Set military service type for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_military_service_type] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = <military_service_type>
	## cardinality = 0..1
	cooldown = bool
}

### Set purge type for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_purge_type] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = <purge_type>
	## cardinality = 0..1
	cooldown = bool
}

### Set slavery type for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_slavery_type] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = <slavery_type>
	## cardinality = 0..1
	cooldown = bool
}

### Set population control for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_population_controls] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = bool
	type = <population_control>
	## cardinality = 0..1
	cooldown = bool
}

### Set colonization control for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_colonization_controls] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = bool
	type = <colonization_control>
	## cardinality = 0..1
	cooldown = bool
}

### Set migration control for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_migration_controls] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = bool
	type = <migration_control>
	## cardinality = 0..1
	cooldown = bool
}

### Set living standard for scoped species/pop/leader
## scopes = { pop leader species }
alias[effect:set_living_standard] = {
	## cardinality = 0..1
	country = scope_group[target_country]
	type = <living_standard>
	## cardinality = 0..1
	cooldown = bool
}

### Joins wars on the side of target country
## scopes = { country }
alias[effect:join_war] = scope_group[target_country]
### Changes closed borders status between two countries
## scopes = { country }
alias[effect:set_closed_borders] = {
	who = scope_group[target_country]
	status = bool
	## cardinality = 0..1
	forced = int_value_field
}

### Declares war between the scoped country and target country
## scopes = { country }
alias[effect:declare_war] = {
	target = scope_group[target_country]
	attacker_war_goal = <war_goal>
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	## push_scope = war
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Adds static war exhaustion, scaled with value_for_planet_destruction, to owner of the battle location
## scopes = { country }
alias[effect:add_static_war_exhaustion] = {
	attacker = scope_group[target_country]
	location = scope[planet] #target planet was omitted here
	value_for_planet_destruction = value_field[0.0..1.0]
}

### Adds diplomatic threat from target country
## scopes = { planet country galactic_object }
alias[effect:add_threat] = {
	who = scope_group[target_country]
	amount = value_field
}

### Adds a Casus Belli to the scoped country against the target country.
## scopes = { country }
alias[effect:add_casus_belli] = {
	type = <casus_belli>
	who = scope_group[target_country]
	days = int_value_field
}

### Sets a war goal to the scoped rebel country/war
## scopes = { country war }
alias[effect:set_war_goal] = {
	type = <war_goal>
	target = scope_group[target_country]
	enemy = scope_group[target_country]
}

### Sets the planet or system as un/surveyed by target country
## scopes = { planet galactic_object }
alias[effect:set_surveyed] = {
	surveyed = bool
	## cardinality = 0..1
	surveyor = scope_group[target_country]
}

### Destroys the target fleet (with death graphics)
## scopes = any
alias[effect:destroy_fleet] = scope[fleet]
### Destroys the target fleet (with death graphics)
## scopes = any
alias[effect:destroy_fleet] = {
	target = scope[fleet]
	## cardinality = 0..1
	kill_leader = bool
	## cardinality = 0..1
	destroy_template = bool
}

### Deletes the target fleet (no death graphics)
## scopes = any
alias[effect:delete_fleet] = scope[fleet]
### Deletes the target fleet (no death graphics)
## scopes = any
alias[effect:delete_fleet] = {
	target = scope[fleet]
	## cardinality = 0..1
	kill_leader = bool
	## cardinality = 0..1
	destroy_template = bool
}

### Deletes the target ship (no death graphics)
## scopes = any
alias[effect:delete_ship] = scope[ship]
### Destroys the target ship (with death graphics)
## scopes = any
alias[effect:destroy_ship] = scope[ship]
### Increases or reduces the size of the scoped planet by a specified amount
## scopes = { planet }
alias[effect:change_planet_size] = int_value_field
#see comment for what should actually be written here
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = random
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = scope[any]
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = localisation
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = {
	## required
	## cardinality = 1..1
	### string in localisation (which contains one or more bracket commands)
	key = localisation
	## required
	## cardinality = 1..inf
	### one of the bracket commands contained in the localisation referenced above, brackets optional (there should be 1 variable_string per unique bracket command)
	variable_string = scalar
}
### Reinstates a previously-exiled leader to the scoped country/fleet/army/pop faction
## scopes = { country fleet army pop_faction }
alias[effect:set_leader] = value[exiled_leader]
### Reinstates a previously-exiled leader to the scoped country/fleet/army/pop faction
## scopes = { country fleet army pop_faction }
alias[effect:set_leader] = last_created_leader
### Reinstates a previously-exiled leader to the scoped country/fleet/army/pop faction
## scopes = { country fleet army pop_faction }
alias[effect:set_leader] = scope_group[target_leader]
### Forces scoped country to evaluate whether to create a specific faction type immediately, rather than monthly
## scopes = { country }
alias[effect:enable_faction_of_type] = <pop_faction>
### Sets the scoped country to be a subject of target country. If use_demanded_terms is set to yes, then the subject agreement will use terms that have previously been demanded in a diplomatic action. If allow_instant_negotiation is set to yes, then the subject and overlord can re-negotiate their agreement right away without having to way for the cooldown. If preset is specified, then the agreement will start as that preset
## scopes = { country }
alias[effect:set_subject_of] = {
	## cardinality = 0..1
	who = scope_group[target_country]
	## cardinality = 0..1
	who = none
	## cardinality = 0..1
	use_demanded_terms = bool
	## cardinality = 0..1
	allow_instant_negotiation = bool
	## cardinality = 0..1
	preset = <agreement_preset>
}

### Removes claims on target system
## scopes = { galactic_object }
alias[effect:remove_claims] = {
	who = scope_group[target_country]
	## cardinality = 0..1
	num_of_claims = int_value_field
}

### Prevents execution of subsequent effects in the same effect block, used with if-statements
## scopes = any
alias[effect:break] = yes
### Destroys the scoped country
## scopes = { country }
alias[effect:destroy_country] = yes
### Destroys the colony on the scoped planet
## scopes = { planet }
alias[effect:destroy_colony] = yes
### Destroys target ambient object
## scopes = any
alias[effect:destroy_ambient_object] = scope[ambient_object]
### Removes the planet from the scope
## scopes = { planet }
alias[effect:remove_planet] = yes
### Removes a single instance of a specific building from the scoped planet
## scopes = { planet }
alias[effect:remove_building] = <building>
### Begins construction of a specific building on the scoped planet
## scopes = { planet }
alias[effect:add_building] = <building>
### Instantly gives a specific tech to the scoped country
## scopes = { country }
alias[effect:give_technology] = {
	tech = <technology>
	## cardinality = 0..1
	message = bool
}

### Copies all techs from the target country to the scoped country, except for some exceptions listed. Tech weights (and weight modifiers) are honoured, meaning that techs a country should not have will not be copied.
## scopes = { country }
alias[effect:copy_techs_from] = {
	target = scope_group[target_country]
	## cardinality = 0..1
	except = {
		## cardinality = 0..inf
		<technology>
	}
}

### Sets the scoped object's graphical culture
## scopes = { megastructure country }
alias[effect:set_graphical_culture] = <graphical_culture>
### Sets the scoped object's graphical culture
## scopes = { megastructure country }
alias[effect:set_graphical_culture] = scope[any]
### Creates a new species
## scopes = any
alias[effect:create_species] = {
	## cardinality = 0..1
	name = scope[any]
	## cardinality = 0..1
	name = random
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	namelist = <name_list>
	## cardinality = 0..1
	namelist = scope_group[target_country]
	## cardinality = 0..1
	namelist = scope[species]
	## cardinality = 0..1
	namelist = random
	## cardinality = 0..1
	namelist = random_class
	## cardinality = 0..1
	plural = scalar
	## cardinality = 0..1
	species_bio = scalar
	## cardinality = 0..1
	adjective = scalar
	class = <species_class>
	class = scope_group[target_species]
	class = random
	class = random_non_machine
	class = random_pre_ftl
	## cardinality = 0..1
	portrait = scope_group[target_species]
	## cardinality = 0..1
	portrait = <portrait>
	## cardinality = 0..1
	portrait = <portrait_group>
	## cardinality = 0..1
	portrait = random
	## cardinality = 0..1
	### Limits species to this gender
	gender = enum[genders_not_set]
	## cardinality = 0..1
	### Limits species to this gender
	gender = scope_group[target_leader]
	## cardinality = 0..1
	### Limits species to this gender
	gender = scope_group[target_species]
	## cardinality = 0..1
	homeworld = scope_group[target_planet]
	## cardinality = 0..1
	homeworld = scope[species]
	# -> traits can be multiple. You can have traits = this, traits = { trait = xyz } at the same time
	## cardinality = 0..2
	traits = scope_group[target_species]
	## cardinality = 0..2
	traits = random
	## cardinality = 0..2
	traits = {
		## cardinality = 0..1
		ideal_planet_class = scope[planet]
		## cardinality = 0..1
		ideal_planet_class = scope_group[target_species]
		## cardinality = 0..1
		ideal_planet_class = <planet_class.habitable_planet>
		## cardinality = 0..10
		trait = <trait.species_trait>
		## cardinality = 0..10
		trait = random_traits
		## cardinality = 0..10
		trait = random_presapient_trait
		## cardinality = 0..10
		add_trait = <trait.species_trait>
	}
	## cardinality = 0..1
	sapient = bool
	## cardinality = 0..1
	### determines if species is a modification of another
	is_mod = bool
	## cardinality = 0..1
	### determines if species leaders are immortal
	immortal = bool
	## cardinality = 0..1
	### determines if pops of that species can colonize
	pops_can_be_colonizers = bool
	## cardinality = 0..1
	### determines if pops of that species can migrate
	pops_can_migrate = bool
	## cardinality = 0..1
	### determines if pops of that species can reproduce
	pops_can_reproduce = bool
	## cardinality = 0..1
	### determines if pops of that species can join factions
	pops_can_join_factions = bool
	## cardinality = 0..1
	### determines if that species can generate leaders
	can_generate_leaders = bool
	## cardinality = 0..1
	### determines if pops from that species can become slaves
	pops_can_be_slaves = bool
	## cardinality = 0..1
	### determines if pops from that species have happiness
	pops_have_happiness = bool
	## cardinality = 0..1
	### determines if pops from need consumer goods
	consumer_goods = bool
	## cardinality = 0..1
	### determines if the species can be modified (default: yes)
	can_be_modified = bool
	## cardinality = 0..1
	### determines if the species can be modified (default: yes)
	can_be_modified = this
	## cardinality = 0..1
	### speed at which the pops from that species grow automatically
	pops_auto_growth = float[0.0..1.0]
	## cardinality = 0..1
	### amount of energy each pop of that species consume monthly
	pop_maintenance = float[0.0..1.0]
	## cardinality = 0..1
	new_pop_resource_requirement = {
		type = <resource>
		type = robot_food
		type = scalar
		value = float
	}
	## cardinality = 0..1
	### Limits species to this gender
	gender = enum[genders_not_set]
	## cardinality = 0..1
	### Limits species to this gender
	gender = scope[species]
	## cardinality = 0..1
	### (default: no)
	clear_parent_species_link = bool
	## cardinality = 0..1
	### (default: yes)
	allow_negative_traits = bool
	## cardinality = 0..1
	extra_trait_points = int
	## cardinality = 0..1
	name_list = <name_list>
	## cardinality = 0..1
	name_list = random
	## cardinality = 0..1
	name_list = scope_group[target_country]
	## cardinality = 0..1
	name_list = scope[species]
	## cardinality = 0..1
	pop_ethics = no
	## cardinality = 0..1
	pop_ethics = random
	## cardinality = 0..1
	pop_ethics = <ethic>
	## cardinality = 0..1
	pop_ethics = {
		## cardinality = 1..3
		<ethic>
		## cardinality = 0..1
		random
	}
	## cardinality = 0..1
	## push_scope = species
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
	## cardinality = 0..1
	blocked_archetypes = {
		## cardinality = 1..inf
		<species_archetype>
	}
}

#if the country is default or anything else that uses them, it really should specify all the details of government, species, etc
### Creates a new country
## scopes = any
alias[effect:create_country] = {
	## cardinality = 0..1
	name = scope[any]
	## cardinality = 0..1
	name = random
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	adjective = scope[any]
	## cardinality = 0..1
	adjective = random
	## cardinality = 0..1
	adjective = localisation
	## cardinality = 0..1
	type = <country_type>
	## cardinality = 0..1
	contact_rule = enum[contact_rules]
	## cardinality = 0..1
	auto_delete = bool
	## cardinality = 0..1
	name_list = <name_list>
	## cardinality = 0..1
	name_list = random
	## cardinality = 0..1
	name_list = scope_group[target_country]
	## cardinality = 0..1
	ship_prefix = scalar	#should be string or a scope
	## cardinality = 0..1
	### Sets country adjective. Allowed values are <string in localisation>/<string written in quotes e.g. "Korean">
	adjective = localisation
	## cardinality = 0..1
	authority = random
	## cardinality = 0..1
	authority = <authority>
	## cardinality = 0..1
	authority = scope_group[target_country]
	## cardinality = 0..1
	civics = scope_group[target_country]
	## cardinality = 0..1
	origin = <civic_or_origin.origin>
	## cardinality = 0..1
	### random includes starting civics
	civics = random
	## cardinality = 0..1
	civics = {
		## cardinality = ~1..4
		civic = <civic_or_origin.civic>
		## cardinality = ~1..4
		civic = random
	}
	## cardinality = 0..1
	species = random
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	randomize_ethos = yes
	## cardinality = 0..1
	### Copies friendliness and hostility data from specified country.
	use_hostilities_from = scope_group[target_country]
	## cardinality = 0..1
	ethos = random
	## cardinality = 0..1
	ethos = scope_group[target_country]
	## cardinality = 0..1
	ethos = {
		## cardinality = 1..3
		## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
		ethic = <ethic>
		## cardinality = 1..3
		## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
		ethic = random
	}
	## cardinality = 0..1
	## push_scope = country
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
	## cardinality = 0..1
	flag = scope_group[target_country]
	## cardinality = 0..1
	flag = random
	## cardinality = 0..1
	flag = {
		#TODO - this is connected to game/flags.
		#I already created an entry for flag colors etc, you should work on connecting these.
		## cardinality = 0..1
		icon = {
			category = scalar			#should be some sort of key
			file = scalar			#should be "filename.dds" in the correct folder
		}
		background = {
			category = scalar			#should be some sort of key
			file = scalar			#should be "filename.dds" in the correct folder
		}
		colors = {
			## cardinality = 0..4
			<color_define>
			## cardinality = 0..4
			"null"
		}
	}
	## cardinality = 0..1
	### Establishing contact on_action (on_first_contact) will not fire for any countries (ever) if this is set to no
	day_zero_contact = bool
	## cardinality = 0..1
	### Establishing contact on_action (on_first_contact) will not fire for this country or its federation allies
	exclude_day_zero_contact = scope_group[target_country]
	## cardinality = 0..1
	released_by_country = scope_group[target_country]	#scope
	## cardinality = 0..1
	released_from_country = scope_group[target_country]	#scope
	## cardinality = 0..1
	ignore_initial_colony_error = bool
	## cardinality = 0..1
	government_restrictions = {
		alias_name[government_trigger] = alias_match_left[government_trigger]
	}
}

### Creates a rebellion
## scopes = { planet }
alias[effect:create_rebels] = {
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	name = scope[any]
	## cardinality = 0..1
	name = random
	authority = random
	authority = <authority>
	authority = scope_group[target_country]
	## cardinality = 0..1
	origin = <civic_or_origin.origin>
	## cardinality = 0..1
	civics = scope_group[target_country]
	### random includes starting civics
	## cardinality = 0..1
	civics = random
	## cardinality = 0..1
	civics = {
		## cardinality = 2..3
		civic = <civic_or_origin.civic>
	}
	species = scope_group[target_species]
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	ethos = random
	## cardinality = 0..1
	ethos = scope_group[target_country]
	## cardinality = 0..1
	ethos = {
		## cardinality = 1..3
		## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
		ethic = <ethic>
	}
	## cardinality = 0..1
	flag = scope_group[target_country]
	## cardinality = 0..1
	flag = random
	## cardinality = 0..1
	flag = {
		#TODO - this is connected to game/flags.
		#I already created an entry for flag colors etc, you should work on connecting these.
		## cardinality = 0..1
		icon = {
			category = scalar			#should be some sort of key
			file = scalar			#should be "filename.dds" in the correct folder
		}
		background = {
			category = scalar			#should be some sort of key
			file = scalar			#should be "filename.dds" in the correct folder
		}
		colors = {
			## cardinality = 0..4
			<color_define>
			## cardinality = 0..4
			"null"
		}
	}
	## cardinality = 0..1
	name_list = <name_list>
	## cardinality = 0..1
	name_list = random
	## cardinality = 0..1
	### This presumably works (report if not)
	ship_prefix = scalar	#should be string or a scope
	## cardinality = 0..1
	released_from_country = scope_group[target_country]
	## push_scope = country
	## severity = warning
	#STNH do some interesting tricks, so I demoted it for their benefit.
	### this is required to spawn rebels for the rebellion to work in the first place
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a new army
## scopes = { planet }
alias[effect:create_army] = {
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	name = random
	owner = scope_group[target_country]
	type = <army>
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	leader = scope_group[target_leader]
	## cardinality = 0..1
	## push_scope = army
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a new leader for the scoped country
## scopes = { country }
alias[effect:create_leader] = {
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	name = random
	class = enum[leader_classes]
	class = random
	## cardinality = 0..1
	### Other scopes will simply default to this.owner_main_species
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	leader_age_min = int
	## cardinality = 0..1
	leader_age_max = int	#should not be less than min...
	## cardinality = 0..1
	gender = enum[genders]
	## cardinality = 0..1
	### Warning: This is in trigger_docs but is not used in this place in Vanilla, and likely does not work
	set_age = int
	## cardinality = 0..1
	skill = random
	## cardinality = 0..1
	skill = int[1..20]
	## cardinality = 0..1
	immortal = bool
	## cardinality = 0..1
	event_leader = bool
	## cardinality = 0..1
	sub_type = enum[trait_ai_classes]
	## cardinality = 0..1
	traits = {
		## cardinality = 0..5
		add_trait = <trait.leader_trait>
		## cardinality = 0..5
		add_trait = random_trait
		## cardinality = 0..5
		trait = <trait.leader_trait>
		## cardinality = 0..5
		trait = random_trait
	}
	## cardinality = 0..1
	## push_scope = leader
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

#Same as create, but all optional except target
### Clones the last created leader for the scoped country
## scopes = { country }
alias[effect:clone_leader] = {
	target = scope_group[target_leader]
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	name = random
	## cardinality = 0..1
	class = enum[leader_classes]
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	leader_age_min = int
	## cardinality = 0..1
	leader_age_max = int	#should not be less than min...
	## cardinality = 0..1
	gender = enum[genders]
	## cardinality = 0..1
	### Warning: This is in trigger_docs but is not used in this place in Vanilla, and likely does not work
	set_age = int
	## cardinality = 0..1
	skill = random
	## cardinality = 0..1
	skill = int[1..20]
	## cardinality = 0..1
	event_leader = bool
	#Not sure what other types there are
	## cardinality = 0..1
	sub_type = survey
	## cardinality = 0..1
	traits = {
		## cardinality = 0..5
		add_trait = <trait.leader_trait>
		## cardinality = 0..5
		add_trait = random_trait
		## cardinality = 0..5
		trait = <trait.leader_trait>
		## cardinality = 0..5
		trait = random_trait
	}
	## cardinality = 0..1
	## push_scope = leader
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Sets the age of the scoped leader
## scopes = { leader }
alias[effect:set_age] = int_value_field
### Creates a new, modified species based on an already-extant species
## scopes = { planet country pop leader species }
alias[effect:modify_species] = {
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	### new base species; default: auto (uses species)
	base = scope_group[target_species]
	## cardinality = 0..1
	base = auto
	## cardinality = 0..1
	base = none
	## cardinality = 0..inf
	add_trait = <trait>
	## cardinality = 0..1
	add_traits_at_start_of_list = bool
	## cardinality = 0..inf
	remove_trait = <trait>
	## cardinality = 0..1
	ideal_planet_class = scope[planet]
	## cardinality = 0..1
	ideal_planet_class = scope_group[target_species]
	## cardinality = 0..1
	ideal_planet_class = <planet_class.habitable_planet>
	## cardinality = 0..1
	### modify scoped pops/planet/leader/country; default: yes
	change_scoped_species = bool
	## cardinality = 0..1
	portrait = scope_group[target_species]
	## cardinality = 0..1
	portrait = <portrait>
	## cardinality = 0..1
	portrait = <portrait_group>
	## cardinality = 0..1
	portrait = random
	## cardinality = 0..1
	## push_scope = species
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Changes the species of the scoped object
## scopes = { country ship pop leader army }
alias[effect:change_species] = scope_group[target_species]
### Changes the dominant species of the current Country, change_all also changes all usage of that species (Pops etc) in the empire
## scopes = { country }
alias[effect:change_dominant_species] = {
	species = scope_group[target_species]
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	change_all = yes
}

### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = <planet_class>
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = <planet_class_random_list>
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = scope_group[target_species]
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = scope[species]
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = {
	class = <planet_class>
	class = <planet_class_random_list>
	class = scope_group[target_species]
	class = scope[species]
	inherit_entity = bool
}

### Sets the planet size to a specified number
## scopes = { planet }
alias[effect:set_planet_size] = int_value_field

### Adds resource deposit to the scoped planet (note: if you add a blocker, it will add a random deposit that can be blocked by that deposit)
## scopes = { planet }
alias[effect:add_deposit] = <deposit>
### Adds resource deposit to the scoped planet (note: if you add a blocker, it will add a random deposit that can be blocked by that deposit)
## scopes = { planet }
alias[effect:add_deposit] = enum[add_deposit_type]
### Replaces resource deposit on the scoped planet
## scopes = { planet }
alias[effect:set_deposit] = <deposit>
### Removes all deposits from the scoped planet
## scopes = { planet }
alias[effect:clear_deposits] = yes

enums = {
	enum[add_deposit_type] = {
		random
		random_blocker
		random_nonblocker
	}
}

### Clear modifiers on target planet
## scopes = { planet }
alias[effect:clear_planet_modifiers] = yes
### Clears resources of a country
## scopes = { country }
alias[effect:clear_resources] = yes
### Rebuild modifiers on target planet
## scopes = { planet }
alias[effect:reroll_planet_modifiers] = yes
### Silently establish communications between scoped country and target country
## scopes = { country }
alias[effect:establish_communications_no_message] = scope_group[target_country]
### Establishes first contact between the scoped country and target country at the set location
## scopes = { country }
alias[effect:establish_contact] = {
	who = scope_group[target_country]
	## cardinality = 0..1
	location = scope_group[celestial_coordinate]
}

### Changes scoped pop to chosen ethic
## scopes = { pop }
alias[effect:pop_change_ethic] = <ethic>
### Starts a situation log event chain for target country
## scopes = any
alias[effect:begin_event_chain] = {
	event_chain = <event_chain>
	## cardinality = 0..1
	target = scope_group[target_country]
}

### Ends a specific situation log event chain for the scoped country
## scopes = { country }
alias[effect:end_event_chain] = <event_chain>
### Increments (or decrements with negative values) an event chain counter for the scoped country by a specific amount
## scopes = { country }
alias[effect:add_event_chain_counter] = {
	event_chain = <event_chain>
	counter = enum[event_chain_counter]
	amount = int_value_field
}

### Enables a specific special research project for target country at a specific location (should be same as the current scope where possible)
## scopes = any
alias[effect:enable_special_project] = {
	name = <special_project>
	## cardinality = 0..1
	owner = scope_group[target_country]
	## cardinality = 0..1
	location = scope_group[spatial_object]
}

### Aborts a specific special project for the country, removing it from the situation log
## scopes = { country }
alias[effect:abort_special_project] = {
	type = <special_project>
	## cardinality = 0..1
	location = scope_group[spatial_object]
}

### Makes the scoped country remember that it has encountered the bypass type
## scopes = { country }
alias[effect:add_seen_bypass_type] = <bypass>
### Spawns a new natural wormhole in the scoped system.
## scopes = { galactic_object }
alias[effect:spawn_natural_wormhole] = {
	bypass_type = <bypass>
	## cardinality = 0..1
	orbit_distance = float #no variables here atm
	## cardinality = 0..1
	orbit_angle = random
	## cardinality = 0..1
	orbit_angle = int[-360..360]
	## cardinality = 0..1
	orbit_angle = {
		min = int[-360..360]
		max = int[-360..360]
	}
	## cardinality = 0..1
	random_pos = bool
}

### Link the wormhole from the scoped system to the wormhole in the target system.
## scopes = { galactic_object }
alias[effect:link_wormholes] = scope[galactic_object]
### Executes an effect on systems with planets owned by the scoped country, starting at an origin, and until a certain percentage of owned planets matching the planet_limit has been covered.
## scopes = { country }
alias[effect:effect_on_blob] = {
	center = scope[galactic_object]
	owned_planets_percentage = value_field[0.0..1.0]
	## push_scope = planet
	planet_limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
	## push_scope = system
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Assign the player of the target country to play the scoped country instead
## scopes = { country }
alias[effect:set_player] = scope_group[target_country]

### Activates the gateway associated with a megastructure.
## scopes = any
alias[effect:activate_gateway] = scope[megastructure]
### Moves a saved leader to the active for the scoped country with a lookup key
## scopes = { country }
alias[effect:activate_saved_leader] = {
	key = value[saved_leader]
	## cardinality = 0..1
	add_to_owned = bool
	## cardinality = 0..1
	## push_scope = leader
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Adds a specific anomaly category to the scoped planet
## scopes = any
alias[effect:add_anomaly] = {
	category = <anomaly_category>
	## cardinality = 0..1
	target = scope_group[target_country]
}

### Adds an asteroid belt at the distance in the scope.
### Example:
## scopes = { galactic_object }
alias[effect:add_asteroid_belt] = {
	radius = int #no variables here atm
	type = <asteroid_belt_type>
}

### Adds to ongoing colonization progress on the scoped planet
## scopes = { planet }
alias[effect:add_colony_progress] = value_field[0.0..1.0]
### Adds a specific global design to the game
## scopes = any
alias[effect:add_global_ship_design] = <global_ship_design>
### Adds a hyperlane between two systems
## scopes = any
alias[effect:add_hyperlane] = {
	from = scope[galactic_object]
	to = scope[galactic_object]
}

### Adds or subtracts progress to/from the scoped observation post's current mission
## scopes = { fleet }
alias[effect:add_mission_progress] = value_field[-1.0..1.0]
### Add a notification modifier to the country
## scopes = { country }
alias[effect:add_notification_modifier] = <notification_modifier>
### Adds s random tech research option to the scoped country's tech view list, permanent until researched. if none applicable it runs fail_effects
## scopes = { country }
alias[effect:add_random_research_option] = {
	## cardinality = 0..1
	category = <technology_category>
	## cardinality = 0..1
	area = enum[technology_areas]
	## cardinality = 0..1
	tier = <technology_tier>
	add_progress = value_field[0.1..1.0]
	## cardinality = 0..1
	fail_effects = {
		alias_name[effect] = alias_match_left[effect]
	}
	## cardinality = 0..1
	### default no
	ignore_prereqs = bool
 	## cardinality = 0..1
	### default yes
	ignore_rare = bool
}

### Adds a tech research option to the scoped country's tech view list, permanent until researched
## scopes = { country }
alias[effect:add_research_option] = <technology>
### Makes the scoped country remember that it has encountered the bypass
## scopes = { country }
alias[effect:add_seen_bypass] = scope_group[spatial_object] #megastructure or wormhole
### Adds a specific ship design to the scoped country
## scopes = { country }
alias[effect:add_ship_design] = scope[design]
### Adds a specific ship design to the scoped country
## scopes = { country }
alias[effect:add_ship_design] = last_created_design
### Adds to the scoped leader's skill level
## scopes = { leader }
alias[effect:add_skill] = int_value_field[-10..20] #check the interval
### Gives percentage progress (0.0-1.0) in a specific tech to the scoped country
## scopes = { country }
alias[effect:add_tech_progress] = {
	tech = <technology>
	progress = value_field[0.1..1.0]
}

### Create and sends an telemetry event keeping track of the tutorial steps for the current game
## scopes = any
alias[effect:complete_tutorial_step] = scalar

### Adds the specified tradition to the scoped country. add_tradition = <tradition_key>
## scopes = { country }
alias[effect:add_tradition] = <tradition>
### Adds trust on scope country towards target country
## scopes = { country }
alias[effect:add_trust] = {
	amount = value_field
	who = scope_group[target_country]
}

### Makes a fleet or ship auto-move to target fleet and potentially attack it
## scopes = { ship fleet }
alias[effect:auto_follow_fleet] = {
	target = scope[fleet]
	attack_fleet = bool
}

### Makes a fleet or ship auto-move to target planet
## scopes = { ship fleet }
alias[effect:auto_move_to_planet] = {
	target = scope[planet]
	target = scope[galactic_object]
	clear_auto_move_on_arrival = bool
	## cardinality = 0..1
	destroy_on_arrival = bool
	## cardinality = 0..1
	arrival_effect = <scripted_effect>
}

### Cancels terraformation of the scoped planet
## scopes = { planet }
alias[effect:cancel_terraformation] = bool
### Changes the scoped country's flag
## scopes = { country }
alias[effect:change_country_flag] = random
### Changes the scoped country's flag
## scopes = { country }
alias[effect:change_country_flag] = {
	icon = {
		category = scalar		#TODO should be a folder name. This needs to be corrected for create_country, create_rebels and prescripted_countries too (possibly more)
		file = scalar		#TODO should be "filename.dds" in the named folder
	}
	background = {
		category = scalar		#TODO should be a folder name
		file = scalar		#TODO should be "filename.dds" in the named folder
	}
	colors = {
		## cardinality = 0..4
		<color_define>
		## cardinality = 0..4
		"null"
	}
}

### Changes the portrait of the leader in scope.
## scopes = { leader }
alias[effect:change_leader_portrait] = scope_group[target_species]
### Changes the portrait of the leader in scope.
## scopes = { leader }
alias[effect:change_leader_portrait] = <portrait>
### Changes the portrait of the leader in scope.
## scopes = { leader }
alias[effect:change_leader_portrait] = <portrait_group>
### Changes the characteristics of a species
## scopes = { species }
alias[effect:change_species_characteristics] = {
	## cardinality = 0..1
	### determines if species is pre-sapient
	sapient = bool
	## cardinality = 0..1
	### determines if species leaders are immortal
	immortal = bool
	## cardinality = 0..1
	### determines if the species can be modified
	can_be_modified = bool
	## cardinality = 0..1
	### determines if the species can be modified
	can_be_modified = scope_field
	## cardinality = 0..1
	portrait = scope_group[target_species]
	## cardinality = 0..1
	portrait = <portrait>
	## cardinality = 0..1
	portrait = <portrait_group>
	## cardinality = 0..1
	portrait = random
	## cardinality = 0..inf
	add_trait = <trait.species_trait>
	## cardinality = 0..inf
	remove_trait = <trait.species_trait>
	## cardinality = 0..1
	### optional, pushes out other traits if needed
	add_traits_at_start_of_list = yes
	## cardinality = 0..1
	### Limits species to this gender
	gender = enum[genders_not_set]
	## cardinality = 0..1
	### Removes species gender restrictions
	gender = any
	## cardinality = 0..1
	### Limits species to this gender
	gender = scope_group[target_leader]
	## cardinality = 0..1
	### Limits species to this gender
	gender = scope_group[target_species]
	## cardinality = 0..1
	### Apply portrait and gender (randomizes new name) changes to existing leaders
	can_change_leader = bool
}

### Re-evaluate the specified casus belli type with given target country
## scopes = { country }
alias[effect:check_casus_belli_valid] = {
	## cardinality = 0..1
	target = scope_group[target_country]
	## cardinality = 0..1
	type = <casus_belli>
}

### Clears all ethics of specified pop or country
## scopes = { country pop }
alias[effect:clear_ethos] = yes
### Clears all queued fleet actions for target fleet
## scopes = { fleet }
alias[effect:clear_fleet_actions] = scope[fleet]
### Deletes the specified saved global target reference
## scopes = any
alias[effect:clear_global_event_target] = value[global_event_target]
### Deletes all saved global target references
## scopes = any
alias[effect:clear_global_event_targets] = yes
### Clears all fleet orders from the scoped fleet
## scopes = { fleet }
alias[effect:clear_orders] = yes
### Clears uncharted space from the galaxy map for the scoped country, in a radius around target system
## scopes = { country }
alias[effect:clear_uncharted_space] = scope[country]
### Clears uncharted space from the galaxy map for the scoped country, in a radius around target system
## scopes = { country }
alias[effect:clear_uncharted_space] = scope[system]

### Conquers the planet by setting its owner to target country and adding an unhappiness modifier
## scopes = { planet }
alias[effect:conquer] = scope_group[target_country]
### Makes the scoped country copy the ethos and government authority of the target country.
## scopes = { country }
alias[effect:copy_ethos_and_authority] = scope_group[target_country]
### Creates a new ambient object
## scopes = any
## replace_scopes = { this = ambient_object root = ambient_object }
alias[effect:create_ambient_object] = {
	type = <ambient_object>
	## cardinality = 0..1
	location = scope_group[celestial_coordinate]
	## cardinality = 0..1
	scale = float
	## cardinality = 0..1
	use_3d_location = bool
	## cardinality = 0..1
	entity_offset = int
	## cardinality = 0..1
	entity_offset = {
		min = int
		max = int
	}
	## cardinality = 0..1
	entity_offset_angle = int
	## cardinality = 0..1
	entity_offset_angle = {
		min = int
		max = int
	}
	## cardinality = 0..1
	entity_offset_height = int
	## cardinality = 0..1
	entity_offset_height = {
		min = int
		max = int
	}
	## cardinality = 0..1
	base_angle_towards = scope_group[spatial_object]
	## cardinality = 0..1
	entity_face_object = scope_group[spatial_object]
	## cardinality = 0..1
	entity_scale_to_size = bool
	## cardinality = 0..1
	play_animation_once = bool
	## cardinality = 0..1
	duration = int
	## cardinality = 0..1
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a new army in a new transport ship
## scopes = { fleet }
## replace_scopes = { this = ship root = ship }
alias[effect:create_army_transport] = {
	## cardinality = 0..1
	graphical_culture = <graphical_culture>
	army_type = <army>
	## cardinality = 0..1
	ship_name = localisation
	## cardinality = 0..1
	army_name = localisation
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a bypass in the parent SpatialObject (stored in FromFrom), of the type passed in "type".
## scopes = { megastructure }
alias[effect:create_bypass] = <bypass>
### Creates a cluster centered around the specified spatial object
## scopes = any
alias[effect:create_cluster] = {
	id = scalar
	radius = float #no variables here atm
	center = scope[system]
}

### Creates a colony on the scoped planet
## scopes = { planet }
alias[effect:create_colony] = {
	owner = scope_group[target_country]
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	species = scalar	#key
	## cardinality = 0..1
	ethos = random
	## cardinality = 0..1
	# Specifically this keyword, not all scopes
	ethos = owner
	## cardinality = 0..1
	ethos = {
		## cardinality = 1..3
		## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
		ethic = <ethic>
	}
}

# create_fleet = { name = <string> effect = { <create_ship, set_owner, set_location etc effects go here> } }
### Creates a new fleet
## scopes = any
## replace_scopes = { this = fleet root = fleet }
alias[effect:create_fleet] = {
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	name = scope[fleet]
	## cardinality = 0..1
	set_take_point = bool
	## cardinality = 0..1
	settings = single_alias_right[fleet_settings]
	## cardinality = 0..1
	### Must include set_owner, set_location and create_ship (here or in last_created_country). Todo: Check this somehow
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Set fleet's settings, any unspecified setting will set to default value.
## scopes = { fleet }
alias[effect:set_fleet_settings] = single_alias_right[fleet_settings]

single_alias[fleet_settings] = {
	## cardinality = 0..1
	spawn_debris = bool
	## cardinality = 0..1
	garrison = bool
	## cardinality = 0..1
	can_upgrade = bool
	## cardinality = 0..1
	can_disband = bool
	## cardinality = 0..1
	can_change_composition = bool
	## cardinality = 0..1
	can_change_leader = bool
	## cardinality = 0..1
	uses_naval_capacity = bool
	## cardinality = 0..1
	is_boss = bool
	## cardinality = 0..1
	ai_ignore_strength = bool
}

### Creates a message, can take multiple variables
## scopes = any
alias[effect:create_message] = {
	type = <message_type>
	localization = localisation
	days = int #no variables here atm
	## cardinality = 0..1
	target = scope[any]
	## cardinality = 0..100
	variable = {
		type = name
		type = variable
		## cardinality = 0..1
		varname = value[variable]
		localization = scalar		#not localisation, but rather something that can be used in localisation
		scope = scope[any]
	}
}

#
### Creates a military fleet with the designs of a specified country.
## scopes = any
alias[effect:create_military_fleet] = {
	owner = scope_group[target_country]
	scaled_size = {
		alias_name[modifier_rule] = alias_match_left[modifier_rule]
	}
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a mining station in orbit of the scoped planet
## scopes = { planet }
alias[effect:create_mining_station] = {
	owner = scope_group[target_country]
	## cardinality = 0..1
	## push_scope = ship
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a point of interest for the scoped country at a specific location, associated with an event chain
## scopes = { planet country ship pop }
alias[effect:create_point_of_interest] = {
	id = value_set[point_of_interest]
	### Leaving out "name" gives a blank button that looks really terrible and unprofessional. Don't do it :P
	## severity = info
	## cardinality = ~1..1
	name = localisation
	#The last comment does not apply here.
	## cardinality = 0..1
	desc = localisation
	event_chain = <event_chain>
	## severity = warning
	## cardinality = 0..1
	location = scope_group[spatial_object]
	## cardinality = 0..1
	location = scope[country]
	## cardinality = 0..1
	location = scope[pop]
	## cardinality = 0..1
	location = scope[leader]
	## cardinality = 0..1
	location = scope[deposit]
	## cardinality = 0..1
	location = scope[army]
	## cardinality = 0..1
	category = scalar
}

### Creates a new pop on the scoped planet
## scopes = { planet }
alias[effect:create_pop] = {
	species = scope_group[target_species]
	species = enum[buildable_pop_species]
	species = scalar	#key
	## cardinality = 0..1
	ethos = random
	## cardinality = 0..1
	ethos = scope[pop]
	## cardinality = 0..1
	ethos = scope_group[target_country]
	## cardinality = 0..1
	ethos = {
		## cardinality = 1..1
		ethic = <ethic>
	}
	## cardinality = 0..1
	## push_scope = pop
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a research station in orbit of the scoped planet
## scopes = { planet }
alias[effect:create_research_station] = {
	owner = scope_group[target_country]
	## cardinality = 0..1
	## push_scope = ship
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a new saved leader for the scoped country with a lookup key
## scopes = { country }
alias[effect:create_saved_leader] = {
	key = value_set[saved_leader]
	## cardinality = 0..1
	creator = scope_group[target_country]
	## cardinality = 0..1
	name = random
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	gender = enum[genders]
	class = random
	class = enum[leader_classes]
	species = scope_group[target_species]
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	event_leader = bool
	## cardinality = 0..1
	set_age = int
	## cardinality = 0..1
	skill = random
	## cardinality = 0..1
	skill = int[1..20]
	## cardinality = 0..1
	traits = {
		## cardinality = 0..5
		add_trait = <trait.leader_trait>
		## cardinality = 0..5
		add_trait = random_trait
		## cardinality = 0..5
		trait = <trait.leader_trait>
		## cardinality = 0..5
		trait = random_trait
	}
	## push_scope = leader
	## cardinality = 0..1
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a new ship
## scopes = { fleet starbase }
alias[effect:create_ship] = {
	## cardinality = 0..1
	name = random
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	name = scope[ship]
	## severity = warning
	## cardinality = 0..1
	design = last_created_design
	## severity = warning
	## cardinality = 0..1
	design = <global_ship_design>
	## severity = warning
	## cardinality = 0..1
	# Hack to handle named designs
	design = localisation
	## severity = warning
	## cardinality = 0..1
	design = scope[design]
	## cardinality = 0..1
	random_existing_design = <ship_size>
	## cardinality = 0..1
	prefix = bool
	## cardinality = 0..1
	graphical_culture = <graphical_culture>
	## cardinality = 0..1
	graphical_culture = scope_group[target_country]
	## cardinality = 0..1
	upgradable = bool
	## cardinality = 0..1
	### Used if the created ship is a colony ship
	colonizer_species = scope_group[target_species]
	## cardinality = 0..1
	## push_scope = ship
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Creates a new ship design for use with last_created_design target
## scopes = any
alias[effect:create_ship_design] = {
	design = localisation
}

### Trigger an assertion to stop the debugger when encountering this effect; argument is ignored
## scopes = any
alias[effect:debug_break] = yes
### Deletes the target mega structure (no death graphics)
## scopes = any
alias[effect:delete_megastructure] = scope[megastructure]
### Dismantles the scoped orbital station (fleet)
## scopes = { fleet }
alias[effect:dismantle] = yes
### Force-end rivalry with target country
## scopes = { country }
alias[effect:end_rivalry] = scope_group[target_country]
### Send endgame telemetry event
## scopes = any
alias[effect:endgame_telemetry] = scalar
### Establish communications between scoped country and target country
## scopes = { country }
alias[effect:establish_communications] = scope_group[target_country]
### Finish the current upgrade of a Mega Structure.
## scopes = { megastructure }
alias[effect:finish_upgrade] = yes
### Sends a fleet to research a special project
## scopes = { fleet }
alias[effect:fleet_action_research_special_project] = {
	special_project = <special_project>
	target = scope_group[spatial_object]
}

### Forces target pop to immediately evaluate their attraction to various pop factions
## scopes = { pop }
alias[effect:force_faction_evaluation] = yes
### Copies a value from the galaxy setup into a variable, optionally scaling it by an int value
## scopes = any
alias[effect:get_galaxy_setup_value] = {
	which = value_set[variable]
	setting = enum[galaxy_setup_values]
	## cardinality = 0..1
	scale_by = int #no variables here atm
}

### Makes a country guarantee another country
## scopes = { country }
alias[effect:guarantee_country] = scope_group[target_country]
### Makes a country guarantee another country
## scopes = { country }
alias[effect:guarantee_country] = {
	### free_guarantee_days is deprecated, does nothing
	target = scope_group[target_country]
}

### Executes the first appropriate effect set for a specific trigger treated as NOT.
## scopes = any
alias[effect:inverted_switch] = {
	trigger = alias_keys_field[trigger]
	## cardinality = 0..inf
	scalar = { alias_name[effect] = alias_match_left[effect] }
	## cardinality = 0..1
	default = { alias_name[effect] = alias_match_left[effect] }
}

### Join federation with target
## scopes = { country }
alias[effect:join_alliance] = {
	who = scope_group[target_country]
	override_requirements = bool
	alias_name[name] = alias_match_left[name]
}

### Removes scoped country from any alliances it is in
## scopes = { country }
alias[effect:leave_alliance] = {
	override_requirements = bool
	## cardinality = 0..1
	apply_opinion_penalty = bool
}

### Prints a message to game.log for debugging purposes.
## scopes = any
alias[effect:log] = {
	alias_name[effect] = alias_match_left[effect]
}

### Prints a message to game.log for debugging purposes.
## scopes = any
alias[effect:log] = scalar
### Modifies army with parameters:
## scopes = { army }
alias[effect:modify_army] = {
	## cardinality = 0..1
	name = random
	## cardinality = 0..1
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	owner = scope_group[target_country]
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	type = <army>
}

### Randomly mutate a species.
## scopes = { species }
alias[effect:mutate_species] = yes

### Forces scoped fleet to retreat to friendly territory
## scopes = { fleet }
alias[effect:order_forced_return] = yes
### Play the defined sound effect
## scopes = any
alias[effect:play_sound] = <sound_effect>
### Adds a specific ethic to the scoped pop regardless if pop-species allows ethic divergence or not.
## scopes = { pop }
alias[effect:pop_force_add_ethic] = <ethic>
### Removes a specific ethic from the scoped pop
## scopes = { pop }
alias[effect:pop_remove_ethic] = <ethic>
### Disables or enables anomaly generation for the scoped planet
## scopes = { planet }
alias[effect:prevent_anomaly] = bool
#randomize_flag_symbol = pirate
### Randomizes a country's flag symbol within the selected category
## scopes = { country }
alias[effect:randomize_flag_symbol] = scalar #TODO pirate
### Removes all armies on scoped planet
## scopes = { planet }
alias[effect:remove_all_armies] = yes
### Removes the scoped army
## scopes = { army }
alias[effect:remove_army] = yes
### Makes a fleet or ship stop auto-moving
## scopes = { ship fleet }
alias[effect:remove_auto_move_target] = yes
### Removes existing hyperlane between two systems
## scopes = any
alias[effect:remove_hyperlane] = {
	from = scope[galactic_object]
	to = scope[galactic_object]
}

### Remove a notification modifier to the country
## scopes = { country }
alias[effect:remove_notification_modifier] = <notification_modifier>
# ### Removes the orbital deposit slot from the scoped planet
#alias[effect:remove_orbital_deposit] = yes
### Removes a specific point of interest from the scoped country's situation log
## scopes = { country }
alias[effect:remove_point_of_interest] = value[point_of_interest]
### Removes a specific ruler trait from the scoped leader, even if they are not currently ruler; this is relevant if they ever become ruler
## scopes = { leader }
alias[effect:remove_ruler_trait] = <trait.leader_trait>
### Removes a saved leader for the scoped country with a lookup key
## scopes = { country }
alias[effect:remove_saved_leader] = value[saved_leader]

### rename_species = {
### use one of the following:
### name = "an entry within the species name database"
### name = random
### name_list = "key"
### }
## scopes = { species }
alias[effect:rename_species] = {
	## cardinality = 0..1
	prompt_country = scope_group[target_country]
	## cardinality = 0..1
	name = scalar
	## cardinality = 0..1
	name = random
	## cardinality = 0..1
	### Name lists defined in the name_lists folder might not work (where would it get the name from?). Rather, Vanilla uses ones defined in species_names. Let Dayshine and Caligula know if ones in name_lists work. (Same with name_list = random and name_list = country).
	name_list = <species_named_list>
}

### Restores a certain percentage of hull points to the scoped ship
## scopes = { ship fleet }
alias[effect:repair_percentage] = value_field[0.0..1.0]

# TODO
### Restores all hull points to the scoped ship
## scopes = { ship }
alias[effect:repair_ship] = yes
### Resets years of peace for a country.
## scopes = { country }
alias[effect:reset_years_of_peace] = yes
### Runs strategic data for AI
## scopes = { country }
alias[effect:run_ai_strategic_data] = yes
### Enables or disables the VIR window pop-in
## scopes = { country }
alias[effect:set_advisor_active] = bool
### Sets the scoped fleet/country's aggro range in intra-system units
## scopes = { country fleet }
alias[effect:set_aggro_range] = int_value_field
### Determines whether the scoped fleet/country's aggro range is measured from the fleet's current position or its spawn location
## scopes = { country fleet }
alias[effect:set_aggro_range_measure_from] = enum[aggro_range_measure_from]

enums = {
	enum[aggro_range_measure_from] = {
		self
		return_point
	}
}

### Sets an asteroid belt at the distance in the scope.
### Example:
## scopes = { galactic_object }
alias[effect:set_asteroid_belt] = {
	## cardinality = 0..1
	radius = float #no variables here atm
	## cardinality = 0..1
	type = <asteroid_belt_type>
}

### Sets the scoped planet to be the capital of its owner country
## scopes = { planet }
alias[effect:set_capital] = yes
### Sets the scoped country's city graphical culture
## scopes = { country }
alias[effect:set_city_graphical_culture] = <graphical_culture>
### Changes the country type of the scoped country
## scopes = { country }
alias[effect:set_country_type] = <country_type>
### Sets the crisis ambient loop to the current effect
## scopes = any
alias[effect:set_crisis_sound] = scalar #TODO sound
### Sets a custom spatial object as custom country capital location.
## scopes = { country }
alias[effect:set_custom_capital_location] = scope_group[spatial_object]
### Sets the scoped ship to become disabled at a certain hull point percentage
## scopes = { ship }
alias[effect:set_disable_at_health] = value_field[0.0..1.0]
### Enables or disables the scoped ship
## scopes = { ship }
alias[effect:set_disabled] = bool
### Sets the flag of the current Empire.
## scopes = { country }
alias[effect:set_empire_flag] = scalar #TODO
### Sets the name of the current Empire.
## scopes = { country }
alias[effect:set_empire_name] = localisation
### Silently disables the scoped fleet to prevent player action, remember to unlock at the end of the event
## scopes = { fleet }
alias[effect:set_event_locked] = bool
### Sets the aggro state of the scoped faction-type country
## scopes = { country }
alias[effect:set_faction_hostility] = {
	## cardinality = 0..1
	target = scope_group[target_country]
	## cardinality = 0..1
	set_hostile = bool
	## cardinality = 0..1
	set_neutral = bool
	## cardinality = 0..1
	set_friendly = bool
}

### Sets a country to lead a federation
## scopes = { country federation }
alias[effect:set_federation_leader] = scalar #TODO unknown unsage
### Sets the bombardment stance of the scoped fleet
## scopes = { fleet }
alias[effect:set_fleet_bombardment_stance] = <bombardment_stance>
### Sets a custom fleet formation on a fleet.
## scopes = { fleet }
alias[effect:set_fleet_formation] = {
	## cardinality = 0..100
	position = {
		x = float
		y = float
	}
}

### Sets the stance of the scoped fleet
## scopes = { fleet }
alias[effect:set_fleet_stance] = enum[fleet_stance]
### Scales the scoped fleet's formation's ship spacing, above and below 1.0
## scopes = { fleet }
alias[effect:set_formation_scale] = value_field
### Sets the mega structure upgrade to halted status for n days. -1 days = indefinitely
## scopes = { megastructure }
alias[effect:set_halted] = int_value_field
### Sets the target leader to be the scoped country's heir
## scopes = { country }
alias[effect:set_heir] = scope[leader]
### Set the home base of the scoped fleet to the specified starbase
## scopes = { fleet }
alias[effect:set_home_base] = scope[starbase]
### Sets the current mission of an observation station
## scopes = { fleet }
alias[effect:set_mission] = <observation_station_mission>
### Change entity of a planet.
### Example:
## scopes = { planet }
alias[effect:set_planet_entity] = {
	## cardinality = 0..1
	entity = scalar	#TODO: Link this to graphical culture <model_entity>
	## cardinality = 0..1
	graphical_culture = <graphical_culture>
	## cardinality = 0..1
	graphical_culture = scope_group[target_country]
	## cardinality = 0..1
	picture = scalar	#filepath #TODO picture
	## cardinality = 0..1
	atmosphere_color = colour[hsv]
	## cardinality = 0..1
	atmosphere_intensity = float[0.0..1.0]
	## cardinality = 0..1
	atmosphere_width = float[0.0..1.0]
}

### Sets the name of the current planet.
## scopes = { planet }
alias[effect:set_planet_name] = scalar
### Sets a policy to a specific option for the scoped country and specifies if policy cooldown should go into effect
## scopes = { country }
alias[effect:set_policy] = {
	policy = <policy>
	option = enum[policy_option]
	## cardinality = 0..1
	cooldown = bool
}

### Sets the scoped pop to belong to a specific pop faction
## scopes = { pop }
alias[effect:set_pop_faction] = <pop_faction>

### Adds or removes a planetary ring around the scoped planet
## scopes = { planet }
alias[effect:set_ring] = bool
### Sets the scoped leader's level
## scopes = { leader }
alias[effect:set_skill] = int_value_field
### Optimizes the calls for spawn_system effect.
### Spawn system should be located in a block between Begin and End.
### Begin: set_spawn_system_batch = begin
### End: set_spawn_system_batch = end
## scopes = any
alias[effect:set_spawn_system_batch] = enum[optimisation_batch]

### Disables modifier system to do full updates between Begin and End.
## scopes = any
alias[effect:set_update_modifiers_batch] = enum[optimisation_batch]

enums = {
	enum[optimisation_batch] = {
		begin
		end
	}
}

### Defines a homeworld for the current species.
## scopes = { species }
alias[effect:set_species_homeworld] = scope_group[target_planet]
### Sets the current species scopes identity to match the target scopes making them evaluate as the same species in is_same_species trigger.
## scopes = { species }
alias[effect:set_species_identity] = scope_group[target_species]
### Sets a building in a slot on a starbase
## scopes = { starbase }
alias[effect:set_starbase_building] = {
	slot = int #no variables here atm
	building = <starbase_building>
}

### Sets a module in a slot on a starbase
## scopes = { starbase }
alias[effect:set_starbase_module] = {
	slot = int #no variables here atm
	module = <starbase_module>
}

### Sets the ship size of a starbase
## scopes = { starbase }
alias[effect:set_starbase_size] = <ship_size.starbase>
### Changes the scoped country's tutorial level (0 none, 1 limited, 2 full)
## scopes = { country }
alias[effect:set_tutorial_level] = enum[tutorial_levels]
### Spawns a mega structure in a system.
## scopes = { galactic_object }
alias[effect:spawn_megastructure] = {
	type = <megastructure>
	## cardinality = 0..1
	planet = scope_group[target_planet]
	## cardinality = 0..1
	coords_from = scope_group[spatial_object]
	alias_name[name] = alias_match_left[name]
	## cardinality = 0..1
	orbit_angle = random
	## cardinality = 0..1
	orbit_angle = int[-360..360]
	## cardinality = 0..1
	orbit_angle = {
		min = int[-360..360]
		max = int[-360..360]
	}
	## cardinality = 0..1
	orbit_distance = float
	## cardinality = 0..1
	owner = scope_group[target_country]
	## cardinality = 0..1
	graphical_culture = <graphical_culture>
	## cardinality = 0..1
	graphical_culture = scope[country]
	## cardinality = 0..1
	graphical_culture = scope[megastructure]
	## cardinality = 0..1
	graphical_culture = scope[ship]
	## cardinality = 0..1
	random_pos = bool
	## cardinality = 0..1
	## push_scope = megastructure
	init_effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Spawns a planet in a system.
## scopes = { galactic_object }
alias[effect:spawn_planet] = {
	class = <planet_class>
	class = <planet_class_random_list>
	## cardinality = 0..1
	name = localisation
	## cardinality = 0..1
	location = scope_group[celestial_coordinate]
	## cardinality = 0..1
	orbit_location = bool
	## cardinality = 0..1
	orbit_distance = float
	## cardinality = 0..1
	orbit_distance_offset = float
	## cardinality = 0..1
	deposit_blockers = none
	## cardinality = 0..1
	modifiers = none
	## cardinality = 0..inf
	modifier = <planet_modifier>
	## cardinality = 0..1
	flags = {
		## cardinality = 0..inf
		value_set[planet_flag]
	}
	## cardinality = 0..1
	size = int
	## cardinality = 0..1
	size = random
	## cardinality = 0..1
	has_ring = bool
	## cardinality = 0..1
	orbit_angle = random
	## cardinality = 0..1
	orbit_angle = float
	## cardinality = 0..1
	orbit_angle_offset = int
	## cardinality = 0..1
	## push_scope = planet
	init_effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Spawns a new system at a position relative to the scoped system/planet/ship.
## scopes = { megastructure planet ship fleet galactic_object starbase no_scope }
alias[effect:spawn_system] = {
	## cardinality = 0..1
	min_distance = float
	## cardinality = 0..1
	max_distance = float
	## cardinality = 0..1
	min_jumps = int[0..1000]
	## cardinality = 0..1
	max_jumps = int[0..1000]
	initializer = <solar_system_initializer>
	## cardinality = 0..1
	hyperlane = bool
	## cardinality = 0..1
	is_discovered = bool
	## cardinality = 0..1
	min_orientation_angle = float
	## cardinality = 0..1
	max_orientation_angle = float
	## cardinality = 0..1
	direction = corewards
	## cardinality = 0..1
	direction = rimwards
	## cardinality = 0..1
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Starts colonization of the scoped planet
## scopes = { planet }
alias[effect:start_colony] = {
	owner = scope_group[target_country]
	## cardinality = 0..1
	species = scope_group[target_species]
	## cardinality = 0..1
	species = enum[buildable_pop_species]
	## cardinality = 0..1
	species = scalar	#key
	## cardinality = 0..1
	ethos = owner
	## cardinality = 0..1
	ethos = {
		## cardinality = 1..10
		ethic = <ethic>
	}
	## cardinality = 0..1
	ethos = random
}

### Stops the crisis ambient loop
## scopes = any
alias[effect:stop_crisis_sound] = yes
### Executes the first appropriate effect set for a specific trigger
## scopes = any
alias[effect:switch] = {
	trigger = alias_keys_field[trigger]
	## cardinality = 0..inf
	scalar = {
		## cardinality = 0..inf
		alias_name[effect] = alias_match_left[effect]
	}
}

### Just a tooltip (shows the effect but does not run it)
## scopes = any
alias[effect:tooltip] = {
	alias_name[effect] = alias_match_left[effect]
}

### if a planet has trigger_megastructure_icon = yes then the map icon for the star will show a megastructure icon
## scopes = { planet }
alias[effect:trigger_megastructure_icon] = yes
### Starts an upgrade process on a mega structure.
## scopes = { megastructure }
alias[effect:upgrade_megastructure_to] = <megastructure>

# 2.2

### Adds specific resource to the stockpile for the country scope:
## scopes = { country }
alias[effect:add_resource] = {
	## cardinality = 1..inf
	<resource> = float
	## cardinality = 0..1
	mult = value_field
	## cardinality = 0..1
	multiplier = value_field
}

### Remove resource deposit on the scoped planet or deposit, does not fire on_cleared if used on a blocker
## scopes = { planet deposit }
alias[effect:remove_deposit] = yes
### Remove resource deposit on the scoped planet or deposit, does not fire on_cleared if used on a blocker
## scopes = { planet deposit }
alias[effect:remove_deposit] = <deposit>

### Fires scoped pop from its job
## scopes = { pop }
alias[effect:unemploy_pop] = yes

### Immediately runs a job evaluation on the planet, firing and employing pops as needed
## scopes = { planet }
alias[effect:check_planet_employment] = yes
### Resets category of a pop
## scopes = { pop }
alias[effect:clear_pop_category] = yes
### Adds random non-blocker resource deposit to the scoped planet
## scopes = { planet }
alias[effect:add_random_non_blocker_deposit] = yes
### Removes last built building from the scoped planet
## scopes = { planet }
alias[effect:remove_last_built_building] = yes
### Removes all buildings from the scoped planet
## scopes = { planet }
alias[effect:remove_all_buildings] = yes
### Repairs all ruined buildings on the scoped planet
## scopes = { planet }
alias[effect:repair_all_buildings] = yes
### Downgrades all non-capital buildings on the scoped planet/country. Leaves tier 1 buildings untouched.
## scopes = { planet country }
alias[effect:downgrade_all_buildings] = yes
### Downgrades all buildings of a specified type on the planet/country.
## scopes = { planet country }
alias[effect:downgrade_buildings_of_type] = <building>
### Instantly adds devastation to scoped planet
## scopes = { planet }
alias[effect:add_planet_devastation] = value_field[-100..100]
### Creates a new pop from a half-species on the planet
## scopes = any
alias[effect:create_half_species] = {
	species_one = scope_group[target_species]
	species_two = scope_group[target_species]
	## cardinality = 0..1
	country = scope_group[target_country]
	## cardinality = 0..1
	## push_scope = species
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Forces target planet or country to calculate its internal modifier
## scopes = { planet country }
alias[effect:calculate_modifier] = yes
### Establish branch office on scoped planet for target country
## scopes = { planet }
alias[effect:establish_branch_office] = scope_group[target_country]
### Close branch office on scoped planet
## scopes = { planet }
alias[effect:close_branch_office] = yes
### Removes all blockers from the scoped planet
## scopes = { planet }
alias[effect:clear_blockers] = yes
### Changes the built species of the scoped object
## scopes = { country }
alias[effect:set_built_species] = scope_group[target_species]
### Removes last built district from the scoped planet
## scopes = { planet }
alias[effect:remove_last_built_district] = yes
### Removes all districts from the scoped planet
## scopes = { planet }
alias[effect:remove_all_districts] = yes
### Removes a specific district from the scoped planet
## scopes = { planet }
alias[effect:remove_district] = <district>
### Begins construction of a specific district on the scoped planet
## scopes = { planet }
alias[effect:add_district] = <district>
### Begins construction of a specific district on the scoped planet
## scopes = { planet }
alias[effect:add_district] = {
	district_type = <district>
	ignore_cap = yes
}

### Enables a resource on the Galactic Market
## scopes = any
alias[effect:enable_on_market] = <resource>
### Enables the galactic market. enable_galactic_market = <yes/no>
## scopes = { country }
alias[effect:enable_galactic_market] = bool
### Checks whether the planets and districts on the planet are valid (their potential triggers are fulfilled), removes or replaces them if not.
## scopes = { planet }
alias[effect:validate_planet_buildings_and_districts] = yes
### Clears scoped deposit blocker and fires its on_cleared effect
## scopes = { deposit }
alias[effect:clear_blocker] = yes
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = scope_group[target_species]
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = <portrait>
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = <portrait_group>
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = random
### Rebuild resource deposits on target planet
## scopes = { planet }
alias[effect:reroll_deposits] = yes

# 2.3

### Creates a archaeological site associated with the scope object
## scopes = { megastructure planet ship fleet galactic_object ambient_object starbase debris }
alias[effect:create_archaeological_site] = <archaeological_site_type>
### Creates a archaeological site associated with the scope object
## scopes = { megastructure planet ship fleet galactic_object ambient_object starbase debris }
alias[effect:create_archaeological_site] = random
### Destroys a archaeological site in right hand site event target
## scopes = any
alias[effect:destroy_archaeological_site] = scope[archaeological_site]
### Adds clues to the current stage of an archaeological or first contact site
## scopes = { archaeological_site first_contact }
alias[effect:add_stage_clues] = int_value_field
### Adds clues to the current stage of an archaeological or first contact site
## scopes = { archaeological_site first_contact }
alias[effect:add_stage_clues] = lower_insight_reward
### Adds clues to the current stage of an archaeological or first contact site
## scopes = { archaeological_site first_contact }
alias[effect:add_stage_clues] = higher_insight_reward
### Adds clues to the current stage of a archaeological site
### add_stage_clues = <int>
## scopes = { archaeological_site }
alias[effect:add_expedition_log_entry] = who_knows_tell_us_please
### Resets the current stage
## scopes = { archaeological_site }
alias[effect:reset_current_stage] = yes
### Sets the current stage for this arc site (first chapter is index 0).
## scopes = { archaeological_site }
alias[effect:set_current_stage] = int[0..inf]
### Finish the current stage
## scopes = { archaeological_site }
alias[effect:finish_current_stage] = yes
### Finish the current stage. yes = trigger stage completed for each stage and current excavator. no = do not trigger any stage completed. country = use this country instead of excavator, no stage complete will be triggered.
## scopes = { archaeological_site }
alias[effect:finish_site] = bool
### Finish the current stage. yes = trigger stage completed for each stage and current excavator. no = do not trigger any stage completed. country = use this country instead of excavator, no stage complete will be triggered.
## scopes = { archaeological_site }
alias[effect:finish_site] = country
### Locks or unlocks the progress of a site
## scopes = { archaeological_site first_contact }
alias[effect:set_site_progress_locked] = bool
### Displays a specific localization string with parameters in tooltip
## scopes = any
alias[effect:custom_tooltip_with_params] = {
	description = localisation
	## cardinality = 0..1
	description_parameters = {
		### Any value can go here to be used in localisation
		## cardinality = 0..inf
		$localisation_parameter = scalar
	}
}

### Adds the specified relic to the scoped country. add_relic = <relic_key>
## scopes = { country }
alias[effect:add_relic] = <relic>
### Removes the specified relic from the scoped country. remove_relic = <relic_key>
## scopes = { country }
alias[effect:remove_relic] = <relic>
### Manually flags an archaeological event as expired
## scopes = { archaeological_site }
alias[effect:expire_site_event] = <event.fleet>

# 2.5.1 (or missing from earlier)

### Adds a specific trait to the scoped leader for a specific duration
## scopes = { leader }
alias[effect:add_timed_trait] = {
	trait = <trait>
	enum[days_months_years] = int_value_field
}

### Recomputes strategic war ( attack / defense ) data for AI = yes
## scopes = { country }
alias[effect:run_ai_strategic_war_data] = yes
### Set scoped country as the current Galactic Market leader. set_market_leader = <yes/no>
## scopes = { country }
alias[effect:set_market_leader] = bool
### Steal all/a random/a specific relic from a target country
## scopes = { country }
alias[effect:steal_relic] = {
	target = scope_group[target_country]
	relic = <relic>
	relic = all
	relic = random
}

# 2.6

### Add <value> favors for scoped country to use on target country.
## scopes = { country }
alias[effect:add_favors] = {
	target = scope_group[target_country]
	value = int_value_field
}

### Remove <value/all> favors that scoped country have on target country:
## scopes = { country }
alias[effect:remove_favors] = {
	target = scope_group[target_country]
	value = int_value_field
	value = all
}

### Sets an arbitrarily-named flag on the scoped federation
## scopes = { federation }
alias[effect:set_federation_flag] = value_set[federation_flag]

### Sets an arbitrarily-named flag on the scoped federation for a set duration
## scopes = { federation }
alias[effect:set_timed_federation_flag] = {
	flag = value_set[federation_flag]
	enum[days_months_years] = int_value_field
}
### Removes a flag from the scoped federation
## scopes = { federation }
## severity = warning
alias[effect:remove_federation_flag] = value[federation_flag]

### Sets the given law for the scoped federation
## scopes = { federation }
alias[effect:set_federation_law] = <federation_law>

### Tries to add the scoped country to the Galactic Community
## scopes = { country }
alias[effect:add_to_galactic_community] = yes

### Tries to add the scoped country to the Galactic Community without producing member joining notifications.
## scopes = { country }
alias[effect:add_to_galactic_community_no_message] = yes

### Tries to remove the scoped country from the Galactic Community
## scopes = { country }
alias[effect:remove_from_galactic_community] = yes

### Tries to add the scoped country to the Galactic Council
## scopes = { country }
alias[effect:add_to_galactic_council] = yes

### Tries to remove the scoped country from the Galactic Council
## scopes = { country }
alias[effect:remove_from_galactic_council] = yes

### Adds experience to the scoped federation
## scopes = { federation }
alias[effect:add_federation_experience] = value_field

### Sets federation type to the scoped federation
## scopes = { federation }
alias[effect:set_federation_type] = <federation_type>

### Sets federation succession type to the scoped federation.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_federation_succession_type] = enum[federation_succession_types]

### Sets federation succession term to the scoped federation. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_federation_succession_term] = enum[federation_succession_terms]

### Sets exclusive right to build fleets by federation leader.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_only_leader_builds_fleets] = bool

### Sets right for subjects to join federations.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_allow_subjects_to_join] = bool

### Sets different voting weight.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_equal_voting_power] = bool

### Sets diplomatic action custom setting.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_diplomacy_action_setting] = {
	action = <diplomatic_action>
	settings = {
		## cardinality = 0..1
		vote_type = enum[vote_types] #unanimous_vote majority_vote leader
		## cardinality = 0..1
		acceptance_type = enum[acceptance_types] #leader default
	}
}

### Sets unified migration flag for federation.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_free_migration] = bool

### Sets diplomatic action custom setting.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_federation_settings] = {
	enum[federation_settings] = bool
}

### Add cohesion to the federation
## scopes = { federation }
alias[effect:add_cohesion] = value_field

### Sets the number of seats on the Galactic Council
## scopes = any
alias[effect:set_council_size] = int_value_field

### Increases the number of seats on the Galactic Council by 1
## scopes = any
alias[effect:increase_council_size] = yes

### Decreases the number of seats on the Galactic Council by 1
## scopes = any
alias[effect:decrease_council_size] = yes

### Sets whether council members can veto resolutions or not
## scopes = any
alias[effect:set_council_veto] = bool

### Sets whether council members can propose emergency measures or not
## scopes = any
alias[effect:set_council_emergency_measures] = bool

### Gives provided country a permanent position on the Galactic Council
## scopes = { country }
alias[effect:add_permanent_councillor] = yes

### Remove the provided country from their permanent council position
## scopes = { country }
alias[effect:remove_permanent_councillor] = yes

### Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type.
## scopes = { country }
alias[effect:pass_resolution] = <resolution>

### Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type. Skips the cooldown on the relevant category.
## scopes = { country }
alias[effect:pass_resolution_no_cooldown] = <resolution>

### Removes a specified country from the war
## scopes = { war }
alias[effect:remove_war_participant] = scope_group[target_country]

### Ends all treaties with the target
## scopes = { country }
alias[effect:end_all_treaties_with] = scope_group[target_country]

# 2.7

### Prints a list of the countries that match the limit triggers in a tooltip, each separated by a line break.
## scopes = any
alias[effect:country_list_tooltip] = {
	## push_scope = country
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
}

### Prints a list of the country's planets that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_planet_list_tooltip] = {
	## push_scope = planet
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
}

### Prints a list of the country's pop factions that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_pop_faction_list_tooltip] = {
	## push_scope = pop_faction
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
}

### Prints a list of the country's leaders that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_leader_list_tooltip] = {
	## push_scope = leader
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
}

### Prints a list of the country's fleets that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_fleet_list_tooltip] = {
	## push_scope = fleet
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
}

### Locks the leader in its current role for the next X days.
## scopes = { leader }
alias[effect:set_cooldown] = int_value_field

### Sets the scoped planet to be the capital of the sector it is part of. If used in the capital sector, it will shift the empire capital. Warning: Experimental, may have unintended consequences.
## scopes = { planet }
alias[effect:set_sector_capital] = yes

### Sets the sector's focus
## scopes = { sector }
alias[effect:set_sector_focus] = <sector_focus>

### Sets the colony's designation type
## scopes = { planet }
alias[effect:set_colony_type] = <colony_type>

### Adds civic to a government without checking the restrictions
## scopes = { country }
alias[effect:force_add_civic] = <civic_or_origin.civic>

### Removes civic from a government without checking the restrictions
## scopes = { country }
alias[effect:force_remove_civic] = <civic_or_origin.civic>

### Completes a specific special project for the country, firing the on complete effects
## scopes = { country }
alias[effect:complete_special_project] = {
	type = <special_project>
	## cardinality = 0..1
	location = scope_group[spatial_object]
}

### Force a truce with target country of a specified type, or a war
## scopes = { country }
alias[effect:set_truce] = {
	target = scope_group[target_country]
	type = enum[truce_types]
}

### Force-end truce with target country
## scopes = { country }
alias[effect:end_truce] = scope_group[target_country]


# 2.8

### Removes a module from a certain slot or all slots on a starbase
## scopes = { starbase }
alias[effect:remove_starbase_module] = {
	## cardinality = 0..1
	### Optional, default = all
	slot = int #no variables here atm
	## cardinality = 0..1
	module = <starbase_module>
}

### Remove a building from a certain slot or all slots on a starbase
## scopes = { starbase }
alias[effect:remove_starbase_building] = {
	## cardinality = 0..1
	### Optional, default = all
	slot = int #no variables here atm
	## cardinality = 0..1
	slot = all
	## cardinality = 0..1
	building = <starbase_building>
}

### Changes the colony foundation date (affecting on_colony_X_years pulses) by a specific number of days. Use with care, you can probably break things with this!
## scopes = { planet }
alias[effect:change_colony_foundation_date] = int_value_field

### Sets the adjective of the scoped country
## scopes = { country }
alias[effect:set_adjective] = localisation
### Sets the adjective of the scoped country
## scopes = { country }
alias[effect:set_adjective] = scope_group[target_country]

### Sets the ship prefix of the scoped country
## scopes = { country }
alias[effect:set_ship_prefix] = localisation
### Sets the ship prefix of the scoped country
## scopes = { country }
alias[effect:set_ship_prefix] = scope_group[target_country]

### Locks the country's government for a given period of days, the default cooldown, or unlocks it.
## scopes = { country }
alias[effect:set_government_cooldown] = int_value_field
### Locks the country's government for a given period of days, the default cooldown, or unlocks it.
## scopes = { country }
alias[effect:set_government_cooldown] = default
### Locks the country's government for a given period of days, the default cooldown, or unlocks it.
## scopes = { country }
alias[effect:set_government_cooldown] = no

### Sets the country's origin to a certain value. Note: This will not run effects executed during galaxy generation.
## scopes = { country }
alias[effect:set_origin] = <civic_or_origin.origin>

# 3.0

### Gives the player the reward for the specified crisis objective
## scopes = { country }
alias[effect:complete_crisis_objective] = <crisis_objective>

### Sets whether the Galactic Emperor can change Imperial Council members or not
## scopes = any
alias[effect:set_emperor_can_change_council_members] = bool

### Sets the specified policy group to have a cooldown as if the policy had just been changed.
## scopes = { country }
alias[effect:set_policy_cooldown] = <policy>

### Sets the current ship or fleet to be destroyed and spawn a debris project for the specified country.
## scopes = { ship fleet }
alias[effect:destroy_and_spawn_debris_for] = scope_group[target_country]

### Sets the star's star class, affecting system and galactic map graphics and potentially modifiers. Also changes the planet class of the system's primary star.
## scopes = { galactic_object }
alias[effect:set_star_class] = <star_class>

### Fires a made-up on_action.
## scopes = any
alias[effect:fire_on_action] = {
	on_action = <on_action>
	## cardinality = 0..1
	scopes = {
		## cardinality = 0..1
		from = scope[any]
		## cardinality = 0..1
		fromfrom = scope[any]
		## cardinality = 0..1
		fromfromfrom = scope[any]
		## cardinality = 0..1
		fromfromfromfrom = scope[any]
	}
}

### Sets the current fleet to go missing in action with the MIA type defided by <key>
## scopes = { fleet }
alias[effect:set_mia] = mia_return_home

### Sets the given stage for the scoped first contact
## scopes = { first_contact }
alias[effect:set_first_contact_stage] = <first_contact_stage>

### Ends the First Contact
## scopes = { first_contact }
alias[effect:finish_first_contact] = yes

### Sets an arbitrarily-named flag on the scoped first contact site
## scopes = { first_contact }
alias[effect:set_first_contact_flag] = value_set[first_contact_flag]

### Sets an arbitrarily-named flag on the scoped first contact site for a set duration
## scopes = { first_contact }
alias[effect:set_timed_first_contact_flag] = {
	flag = value_set[first_contact_flag]
	enum[days_months_years] = int_value_field
}
### Removes a flag from the scoped first contact site
## scopes = { first_contact }
## severity = warning
alias[effect:remove_first_contact_flag] = value[first_contact_flag]

### Prints a custom error to the error log
## scopes = any
alias[effect:log_error] = scalar

### Adds a random tech from the target country within the given category and tech area constraints. The country must be able to research said tech (weight > 0, fulfils potential trigger)
## scopes = { country }
alias[effect:copy_random_tech_from] = {
	who = scope_group[target_country]
	## cardinality = 0..1
	category = <technology_category>
	## cardinality = 0..1
	area = enum[research_areas]
	## cardinality = 0..1
	### Optional: this makes it grant the tech option rather than the whole tech
	progress = value_field[0.0..1.0]
}

### Adds the defined amount of intel toward the target empire.
## scopes = { country }
alias[effect:add_intel] = {
	who = scope_group[target_country]
	amount = value_field
}

### Creates espionage asset within a given spy network
## scopes = { spy_network }
alias[effect:create_espionage_asset] = {
	type = <espionage_asset>
	## cardinality = 0..1
	## push_scope = espionage_asset
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

### Destroys espionage asset within a given spy network/operation
## scopes = { spy_network espionage_operation }
alias[effect:destroy_espionage_asset] = <espionage_asset>

### Locks or unlocks the progress of an espionage operation
## scopes = { espionage_operation }
alias[effect:set_espionage_operation_progress_locked] = bool

### Unassigns espionage asset from the scope operation to owning spy network
## scopes = { espionage_operation }
alias[effect:unassign_espionage_asset] = <espionage_asset>

### Assigns espionage asset to the scope operation from owning spy network
## scopes = { espionage_operation }
alias[effect:assign_espionage_asset] = <espionage_asset>

### Sets an arbitrarily-named flag on the scoped espionage operation
## scopes = { espionage_operation }
alias[effect:set_espionage_operation_flag] = value_set[espionage_operation_flag]

### Removes a flag from the scoped espionage operation
## scopes = { espionage_operation }
alias[effect:remove_espionage_operation_flag] = value[espionage_operation_flag]
### Sets an arbitrarily-named flag on the scoped espionage operation for a set duration
## scopes = { espionage_operation }
## severity = warning
alias[effect:set_timed_espionage_operation_flag] = {
	flag = value_set[espionage_operation_flag]
	enum[days_months_years] = int_value_field
}

### Joins the war on the specified side.
## scopes = { country }
alias[effect:join_war_on_side] = {
	war = scope[war]
	side = enum[war_sides]
	side = scope_group[target_country]
}

### Remove a number of random building(s) matching/not matching a type from the starbase
## scopes = { starbase }
alias[effect:remove_random_starbase_building] = {
	## cardinality = 0..1
	type = <starbase_building>
	## cardinality = 0..1
	count = int #no variables here atm
}

### Remove a number of random module(s) matching/not matching a type from the starbase
## scopes = { starbase }
alias[effect:remove_random_starbase_module] = {
	## cardinality = 0..1
	type = <starbase_module>
	## cardinality = 0..1
	count = int #no variables here atm
}

### Destroys a espionage operation site in right hand site event target
## scopes = any
alias[effect:destroy_espionage_operation] = scope[espionage_operation]

### Adds information to the current stage of an espionage operation
## scopes = { espionage_operation }
alias[effect:add_espionage_information] = value_field

### Adds victory score to a country
## scopes = { country }
alias[effect:add_victory_score] = {
	source = localisation
	score = value_field
}

### Stores a copy of the specified data of the scoped country. The values default to 'no'.
## scopes = { country }
alias[effect:store_country_backup_data] = {
	## cardinality = 0..1
	flag = bool
	## cardinality = 0..1
	room = bool
	## cardinality = 0..1
	name = bool
	## cardinality = 0..1
	ethics = bool
	## cardinality = 0..1
	government = bool
}

### Restores backed up data to the country
## scopes = { country }
alias[effect:restore_country_backup_data] = bool

### Activates crisis progression for the country
## scopes = { country }
alias[effect:activate_crisis_progression] = yes

### Sets the room background of the empire. Provide an empty string to remove the override.
## scopes = { country }
alias[effect:room_name_override] = <asset_selector.room>
### Sets the room background of the empire. Provide an empty string to remove the override.
## scopes = { country }
alias[effect:room_name_override] = ""

### Sets the AI personality of a country to a new one
## scopes = { country }
alias[effect:set_ai_personality] = <ai_personality>

### Sets whether or not the scoped country is the Galactic Custodian
## scopes = { country }
alias[effect:set_galactic_custodian] = bool

### Sets whether or not the scoped country is the Galactic Emperor
## scopes = { country }
alias[effect:set_galactic_emperor] = bool

### Sets whether the Galactic Defense force or Imperial Armada exists
## scopes = any
alias[effect:set_galactic_defense_force] = bool

### Add imperial_authority
## scopes = any
alias[effect:add_imperial_authority] = value_field

### Adds a specific modifier to the current espionage operation stage for a set duration or until stage is changed
## scopes = { espionage_operation }
alias[effect:add_stage_modifier] = {
	modifier = <static_modifier>
	# severity = info
	## cardinality = 0..1
	enum[days_months_years] = int
	## cardinality = 0..1
	multiplier = float #no variables here atm
}

### Removes a specific modifier from the espionage operation current stage
## scopes = { espionage_operation }
alias[effect:remove_stage_modifier] = <static_modifier>

### Moves all owned GDF fleets to the target.
## scopes = { country }
alias[effect:transfer_galactic_defense_force_fleets] = scope_group[target_country]

### Immediately cancels/removes the latest active/passed/proposed/voting for/failed resolution of this type
## scopes = { country }
alias[effect:cancel_resolution] = <resolution>

### Adds the intel level for the category selected. Default duration (0) is forever.
## scopes = { country }
alias[effect:add_intel_report] = {
	category = <intel_category>
	level = int
	## cardinality = 0..1
	days = int
	who = scope_group[target_country]
}

### Removes all the intel reports related to the provided category.
## scopes = { country }
alias[effect:clear_intel_report] = {
	category = <intel_category>
	who = scope_group[target_country]
}

### Rounds a previously-set variable to the closest integer.
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:round_variable] = value[variable]

### Rounds a previously-set variable down to the previous integer.
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:floor_variable] = value[variable]

### Rounds a previously-set variable up to the next integer.
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:ceiling_variable] = value[variable]

### Exports the value of a trigger to a specified variable (so for num_pops, it'll export the number of pops).
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:export_trigger_value_to_variable] = {
	## cardinality = 0..1
	### specify extra parameters for triggers with { }, e.g. resource = energy
	parameters = {
		## cardinality = 0..1
		## push_scope = any
		limit = {
			alias_name[trigger] = alias_match_left[trigger]
		}
		## cardinality = 0..inf
		scalar = $any # not only scalar, but also can be a nested clause
	}
	trigger = alias_keys_field[trigger]
	variable = value_set[variable]
}

### Exports the value of the current country's stockpile of the specified resource to a variable.
## scopes = { country }
alias[effect:export_resource_stockpile_to_variable] = {
	resource = <resource>
	variable = value_set[variable]
}

### Exports the value of the current country's monthly income of the specified resource to a variable.
## scopes = { country }
alias[effect:export_resource_income_to_variable] = {
	resource = <resource>
	variable = value_set[variable]
}

### Exports the value of a specified modifier in the current scope to a specified variable.
## scopes = { megastructure planet country ship pop fleet galactic_object leader army species pop_faction }
alias[effect:export_modifier_to_variable] = {
	modifier = alias_keys_field[modifier]
	variable = value_set[variable]
}

### Sets the target country as hostile. This will work on countries you don't have comms with, unlike set_faction_hostility.
## scopes = { country }
alias[effect:set_hostile] = scope_group[target_country]

### Add specified country as an associate member
## scopes = { federation }
alias[effect:add_associate_member] = {
	who = scope_group[target_country]
	override_requirements = bool
}

### Removes a specific associate member from the federation
## scopes = { federation }
alias[effect:remove_associate_member] = {
	who = scope_group[target_country]
	override_requirements = bool
}

### Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type that has the specified target. Ignores whether the target is valid or not.
## scopes = { country }
alias[effect:pass_targeted_resolution] = {
	resolution = <resolution>
	target = scope_group[target_country]
}

### Increase the current Custodian term time
## scopes = any
alias[effect:add_custodian_term_days] = int_value_field

### Set the current Custodian term time. -1 will make the Custodianship permanent.
## scopes = any
alias[effect:set_custodian_term_days] = int_value_field

### The scoped country wins the game
## scopes = { country }
alias[effect:win] = yes

### Adds levels to the current Spy Network
## scopes = { spy_network }
alias[effect:add_spy_network_level] = int_value_field

### Dissolved the current federation
## scopes = { federation }
alias[effect:dissolve_federation] = yes

# 3.1

### Sets the country's male ruler title to a custom value
## scopes = { country }
alias[effect:set_male_ruler_title] = localisation
### Sets the country's female ruler title to a custom value
## scopes = { country }
alias[effect:set_female_ruler_title] = localisation
### Sets the country's male heir title to a custom value
## scopes = { country }
alias[effect:set_male_heir_title] = localisation
### Sets the country's female heir title to a custom value
## scopes = { country }
alias[effect:set_female_heir_title] = localisation
### Clears all custom ruler and heir titles from the country, resetting them to default values
## scopes = { country }
alias[effect:clear_custom_ruler_and_heir_titles] = yes

### Adds a blocker to a planet, with some control over what it is set to block (add_deposit will add a random planetary deposit to block)
## scopes = { planet }
alias[effect:add_blocker] = {
	type = <deposit.blocker>
	## cardinality = 0..1
	### none is default, if you specify a scope or random then it copies the type to the blocked deposit but any flags or variables are lost
	blocked_deposit = random
	## cardinality = 0..1
	blocked_deposit = none
	## cardinality = 0..1
	blocked_deposit = scope[deposit]
}

### Sets an arbitrarily-named date flag for the scoped object. Acts both as an <scope object>_flag and as a means for saving a date. The flag can then be referred to in localisations [This.<flag>] to produce the date.
## scopes = { megastructure planet country ship pop fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation }
alias[effect:set_saved_date] = {
	### Refer to this in locs; note: this is actually a <country/whatever>_flag
	key = scalar #todo: actually a flag of the current scope type
	## cardinality = 0..1
	### Time until the date you wish to save. Default is present
	days_from_present = int_value_field
	## cardinality = 0..1
	### Time until the saved date is cleared, default is never
	expires = int_value_field
}

### Rerolls the random seed. Use if you want to have a second random_list return a different result. Do not use in tooltips that show random results, because the tooltip will be wrong!
## scopes = any
alias[effect:reroll_random] = yes

### Sets the target system as 'visited' (i.e. low system intel on the map)
## scopes = { country }
alias[effect:set_visited] = scope[system]

### Creates a new Nebula with a given radius centered around the current system.
## scopes = { galactic_object }
alias[effect:create_nebula] = {
	## cardinality = 0..1
	### (loc, optional - default is random)
	name = localisation
	## required
	radius = int_value_field
	## cardinality = 0..1
	## push_scope = galactic_object
	### effects on every system in the new nebula
	effect = {
		alias_name[effect] = alias_match_left[effect]
	}
}

# 3.3

### Begins a situation.
## scopes = { country }
alias[effect:start_situation] = {
	type = <situation_type>
	## cardinality = 0..1
	target = scope[any]
	## cardinality = 0..1
	## push_scope = situation
	effect = { alias_name[effect] = alias_match_left[effect] }
}

### Destroys a situation in right hand side event target, use once situation is complete (on_fail/on_complete/on_abort is not called)
## scopes = any
alias[effect:destroy_situation] = scope[situation]
### Adds a sum of progress scoped situation
## scopes = { situation }
alias[effect:add_situation_progress] = value_field
### Sets the approach to the Situation. Respects allow and potential triggers.
## scopes = { situation }
alias[effect:set_situation_approach] = enum[situation_approaches]
### Sets the planet's ascension tier to the specified value
## scopes = { planet }
alias[effect:set_planetary_ascension_tier] = int_value_field
### Disables a single instance of a specific building on the scoped planet
## scopes = { planet }
alias[effect:disable_building] = <building>
### Ruins a single instance of a specific building on the scoped planet
## scopes = { planet }
alias[effect:ruin_building] = <building>
### Locks the Situation so it will not progress until unlocked.
## scopes = { situation }
alias[effect:set_situation_locked] = bool
### Changes the agreement term for whether the Subject can be integrated
## scopes = { agreement }
alias[effect:set_rule_can_subject_be_integrated] = bool
### Changes the agreement term for whether the Subject can do diplomacy
## scopes = { agreement }
alias[effect:set_rule_can_subject_do_diplomacy] = bool
### Changes the agreement term for whether the Subject can expand
## scopes = { agreement }
alias[effect:set_rule_can_subject_expand] = enum[agreement_subject_expand]
### Changes the agreement term for whether the Subject can vote independently of its overlord in GalCom/federations
## scopes = { agreement }
alias[effect:set_rule_can_subject_vote] = bool
### Changes the agreement term for Subject to join Overlord wars
## scopes = { agreement }
alias[effect:set_rule_join_overlord_wars] = enum[agreement_wars]
### Changes the agreement term for Overlord to wars of its Subject
## scopes = { agreement }
alias[effect:set_rule_join_subject_wars] = enum[agreement_wars]
### Changes the agreement term for whether the Subject can access the overlord's territory (and territories the overlord has access to) despite closed borders
## scopes = { agreement }
alias[effect:set_rule_subject_has_access] = bool
### Changes the agreement term for whether the Subject gets sensors data from Overlord
## scopes = { agreement }
alias[effect:set_rule_subject_has_sensors] = bool
### Passes the scoped debris ownership to the specified country
## scopes = { debris }
alias[effect:pass_debris_ownership] = {
	owner = scope_group[target_country]
}

### Replace/removes all invalid (potential trigger not fulfilled) buildings and districts, then repairs all ruined buildings on the scoped planet
## scopes = { planet }
alias[effect:validate_and_repair_planet_buildings_and_districts] = yes

### Removes a specific holding from the scoped planet
## scopes = { planet }
alias[effect:remove_holding] = {
	holding = <building.corporate>
	holding = <building.holding>
	owner = scope_group[target_country]
}
### Begins construction of a specific holding on the scoped planet
## scopes = { planet }
alias[effect:add_holding] = {
	holding = <building.corporate>
	holding = <building.holding>
	owner = scope_group[target_country]
}
### Removes a secret fealty pact between the scoped subject country and the target empire
## scopes = { country }
alias[effect:remove_secret_fealty] = scope_group[target_country]

### Clears relations between scoped and target countries
## scopes = { country }
alias[effect:clear_relations] = {
	target = scope[country]
	relations = { enum[country_relation] }
}

### Sets agreement terms of the agreement. Can be used to set multiple terms at once, including resource subsidies.
alias[effect:set_agreement_term] = {
	## cardinality = 0..inf
	<agreement_term.discrete> = <agreement_term_value.discrete>
	## cardinality = 0..inf
	<agreement_term.discrete_number> = <agreement_term_value.discrete_number>
	## cardinality = 0..inf
	<agreement_term.specialist_type> = <agreement_term_value.specialist_type>
	## cardinality = 0..inf
	<agreement_term.resource> = value_field[-1.0..1.0]
}
### Sets the preset of an agreement and applies its terms on the agreement if 'apply_terms' is 'yes'.
## scopes = { agreement }
alias[effect:set_agreement_preset] = {
	preset = <agreement_preset>
	## cardinality = 0..1
	### Defaults to 'yes'
	apply_terms = bool
}
### Adds a ship component to a starbase, standalone from any module or building
## scopes = { starbase }
alias[effect:add_starbase_component] = {
	component = <component_template.starbase>
}
### Removes the specified ship component to a starbase. Only works for components that are standalone from any module or building.
## scopes = { starbase }
alias[effect:remove_starbase_component] = {
	component = <component_template.starbase>
}
### Add loyalty to subject of an agreement
## scopes = { agreement }
alias[effect:add_loyalty] = int_value_field
### Sets an arbitrarily-named flag on the scoped design
## scopes = { design }
## severity = warning
alias[effect:set_design_flag] = value_set[design_flag]
### Removes a flag from the scoped design
## scopes = { design }
## severity = warning
alias[effect:remove_design_flag] = value_set[design_flag]
## severity = warning
### Sets an arbitrarily-named flag on the scoped country for a set duration
alias[effect:set_timed_design_flag] = {
	flag = value_set[design_flag]
	enum[days_months_years] = int_value_field
}
### Destroys a situation in right hand side event target, firing on_abort (use to cancel and fire that effect)
## scopes = any
alias[effect:abort_situation] = scope[situation]
### Starts the process of converting the subject of the scoped agreement to the given specialist type
### Can also be used to remove the specialization from a subject, by using 'none' as value
## scopes = { agreement }
alias[effect:convert_to_specialist] = <agreement_term_value.specialist_type>
### Starts the process of converting the subject of the scoped agreement to the given specialist type
### Can also be used to remove the specialization from a subject, by using 'none' as value
## scopes = { agreement }
alias[effect:convert_to_specialist] = none
### Removes a specific ship design from the scoped country
## scopes = { country }
alias[effect:remove_ship_design] = scope[design]
### Removes a specific ship design from the scoped country
## scopes = { country }
alias[effect:remove_ship_design] = last_created_design
### Removes a specific global design from the game
## scopes = any
alias[effect:remove_global_ship_design] = <global_ship_design>
### Passes special trade offer data from the target enclave country to the scoped country.
### Only works inside certain parts of the script marked as ai_trade_facility.
## scopes = { country }
alias[effect:get_trade_data] = {
	target = scope_group[target_country]
}
### Makes special trade deal between the target enclave country and the scoped country.
### Only works inside certain parts of the script marked as ai_trade_facility.
## scopes = { country }
alias[effect:make_special_trade] = {
	target = scope_group[target_country]
}
### Leases fleet out to the new controller country for a numbed of days
## scopes = { fleet }
alias[effect:give_fleet] = {
	controller = scope_group[target_country]
	days = int_value_field
}
### Breaks fleet lease contract
alias[effect:break_fleet_contract] = bool
### Prolongs fleet's lease contract for a numbed of days
## scopes = { fleet }
alias[effect:prolong_fleet_contract] = {
	days = int_value_field
}

### Sets agreement terms of the agreement. Can be used to set multiple terms at once, including resource subsidies.
## scopes = { agreement }
alias[effect:set_agreement_terms] = {
	## cardinality = 0..inf
	<agreement_term> = scalar
}

# 3.5

### Multiplies crisis strength by this factor.
## scopes = any
alias[effect:multiply_crisis_strength] = value_field

### Sets the scoped leader immortal. The 'no' case will not override immortality granted by species characteristics (but will disable immortality granted by this effect).
## scopes = { leader }
alias[effect:set_immortal] = bool

### Used with enclave_mercenary to remove fleet contract modifiers.
alias[effect:remove_fleet_contract_modifiers] = bool

### Finish the current operation phase
### yes - trigger stage completed for each stage and current excavator.
### no - do not trigger any stage completed
## scopes = { espionage_operation }
alias[effect:finish_current_operation_stage] = bool

### Breaks fleet lease contract
## scopes = { fleet }
alias[effect:end_fleet_contract] = yes

### Sets awareness for the scoped (pre-FTL) country
## scopes = { country }
alias[effect:set_awareness] = float[0.0..100.0]

### Sets awareness for the scoped (pre-FTL) country
## scopes = { country }
alias[effect:add_awareness] = float

# fleet actions

### Adds actions to the scoped fleet's action queue
## scopes = { fleet }
alias[effect:queue_actions] = {
	alias_name[fleet_action] = alias_match_left[fleet_action]
}

### Sets current fleet's cloaking status
## scopes = { fleet }
alias[effect:set_cloaking_active] = bool

### Advances country to next pre-FTL technology level if possible. Does nothing if has_next_pre_ftl_age would be false, or if argument is 'no'.
## scopes = { country }
alias[effect:go_to_next_pre_ftl_age] = bool

### Set pre-FTL technology level. Does nothing if the country is not pre-FTL.
## scopes = { country }
alias[effect:set_pre_ftl_age] = <pre_ftl_age>

### Remove communications between scoped country and target country
## scopes = { country }
alias[effect:remove_communications] = scope[country]

### Removes any envoys from scoped country assigned to target country
## scopes = { country }
alias[effect:remove_envoys_to] = scope[country]

### The scoped country is removed from any federation its in
## scopes = { country }
alias[effect:remove_from_federation] = yes

### Repairs a single instance of a specific building on the scoped planet
## scopes = { planet }
alias[effect:repair_building] = <building>

# scope links

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country fleet }
## push_scope = ship
alias[effect:every_owned_ship] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country fleet }
## push_scope = ship
alias[effect:random_owned_ship] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Executes enclosed effects on a random pop that meets the limit criteria. Warning: deprecated, use random_owned_pop
## scopes = { planet }
## push_scope = pop
alias[effect:random_pop] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all owned pops - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet country pop_faction sector }
## push_scope = pop
alias[effect:every_owned_pop] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects for every pop in the game that meet the limit criteria
## scopes = any
## push_scope = pop
alias[effect:every_galaxy_pop] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all playable countries - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_playable_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_playable_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = planet
alias[effect:random_system_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each deposit on the planet - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = deposit
alias[effect:every_deposit] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = deposit
alias[effect:random_deposit] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = planet
alias[effect:random_moon] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each moon of the planet - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = planet
alias[effect:every_moon] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet within the current empire's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = planet
alias[effect:every_planet_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all rim systems - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = system
alias[effect:every_rim_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = system
alias[effect:random_rim_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each leader that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = leader
alias[effect:every_owned_leader] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = leader
alias[effect:random_owned_leader] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet country pop_faction sector }
## push_scope = pop
alias[effect:random_owned_pop] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Executes enclosed effects on a system -within a specific number of jumps span- that meets the limit criteria. This completely ignores bypasses (wormholes and gateways)
## scopes = any
## push_scope = system
alias[effect:closest_system] = {
	## cardinality = 0..1
	min_steps = int
	## cardinality = 0..1
	max_steps = int
	## cardinality = 0..1
	use_bypasses = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = fleet
alias[effect:random_owned_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = ambient_object
alias[effect:random_ambient_object] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = ambient_object
alias[effect:random_system_ambient_object] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every ambient object in the game - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = ambient_object
alias[effect:every_ambient_object] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every ambient object in the solar system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = ambient_object
alias[effect:every_system_ambient_object] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = fleet
alias[effect:every_fleet_in_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = fleet
alias[effect:random_fleet_in_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = system
alias[effect:every_neighbor_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = system
alias[effect:random_neighbor_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all war participants - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { war }
## push_scope = country
alias[effect:every_war_participant] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = fleet
alias[effect:every_owned_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all subjects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_subject] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_subject] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = planet
alias[effect:random_planet_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Executes enclosed effects on every system in the cluster that meet the limit criteria
## scopes = any
## push_scope = system
alias[effect:every_system_in_cluster] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all the country's pop factions - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = pop_faction
alias[effect:every_pop_faction] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = pop_faction
alias[effect:random_pop_faction] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet (colony or not) in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = planet
alias[effect:every_system_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country no_scope }
## push_scope = agreement
alias[effect:random_agreement] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country no_scope }
## push_scope = agreement
alias[effect:ordered_agreement] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each agreement - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country no_scope }
## push_scope = agreement
alias[effect:every_agreement] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = ambient_object
alias[effect:ordered_ambient_object] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = ambient_object
alias[effect:ordered_system_ambient_object] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = archaeological_site
alias[effect:random_archaeological_site] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = archaeological_site
alias[effect:ordered_archaeological_site] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every archaeological sites - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = archaeological_site
alias[effect:every_archaeological_site] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = army
alias[effect:random_owned_army] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = army
alias[effect:ordered_owned_army] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = army
alias[effect:every_owned_army] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = army
alias[effect:random_planet_army] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = army
alias[effect:ordered_planet_army] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}


### Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = army
alias[effect:every_planet_army] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}


### Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = army
alias[effect:random_ground_combat_defender] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = army
alias[effect:ordered_ground_combat_defender] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = army
alias[effect:every_ground_combat_defender] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = army
alias[effect:random_ground_combat_attacker] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = army
alias[effect:ordered_ground_combat_attacker] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = army
alias[effect:every_ground_combat_attacker] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_country] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_relation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_relation] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all relations - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_relation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_neighbor_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_neighbor_country] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all neighbor countries - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_neighbor_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = country
alias[effect:random_country_neighbor_to_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = country
alias[effect:ordered_country_neighbor_to_system] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = country
alias[effect:every_country_neighbor_to_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_rival_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_rival_country] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries rivalled by the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_rival_country] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_federation_ally] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_federation_ally] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries in a federation with the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_federation_ally] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_playable_country] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_subject] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = debris
alias[effect:random_available_debris] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = debris
alias[effect:ordered_available_debris] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = debris
alias[effect:every_available_debris] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}


### Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = design
alias[effect:random_owned_design] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = design
alias[effect:ordered_owned_design] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all designs owned by the current country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = design
alias[effect:every_owned_design] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country no_scope }
## push_scope = spy_network
alias[effect:random_spynetwork] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country no_scope }
## push_scope = spy_network
alias[effect:ordered_spynetwork] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each spynetwork - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country no_scope }
## push_scope = spy_network
alias[effect:every_spynetwork] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country no_scope spy_network }
## push_scope = espionage_operation
alias[effect:random_espionage_operation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country no_scope spy_network }
## push_scope = espionage_operation
alias[effect:ordered_espionage_operation] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage operation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country no_scope spy_network }
## push_scope = espionage_operation
alias[effect:every_espionage_operation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { no_scope spy_network espionage_operation }
## push_scope = espionage_asset
alias[effect:random_espionage_asset] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { no_scope spy_network espionage_operation }
## push_scope = espionage_asset
alias[effect:ordered_espionage_asset] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage asset - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { no_scope spy_network espionage_operation }
## push_scope = espionage_asset
alias[effect:every_espionage_asset] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = federation
alias[effect:random_federation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}


### Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = federation
alias[effect:ordered_federation] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each federation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = federation
alias[effect:every_federation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = first_contact
alias[effect:random_first_contact] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = first_contact
alias[effect:ordered_first_contact] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = first_contact
alias[effect:every_first_contact] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = first_contact
alias[effect:random_active_first_contact] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = first_contact
alias[effect:ordered_active_first_contact] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = first_contact
alias[effect:every_active_first_contact] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = fleet
alias[effect:random_galaxy_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = fleet
alias[effect:ordered_galaxy_fleet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the entire game - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = fleet
alias[effect:every_galaxy_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { fleet }
## push_scope = fleet
alias[effect:random_combatant_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { fleet }
## push_scope = fleet
alias[effect:ordered_combatant_fleet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet this fleet is in combat with - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { fleet }
## push_scope = fleet
alias[effect:every_combatant_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = fleet
alias[effect:ordered_fleet_in_system] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = fleet
alias[effect:ordered_owned_fleet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = fleet
alias[effect:random_controlled_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = fleet
alias[effect:ordered_controlled_fleet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = fleet
alias[effect:every_controlled_fleet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { megastructure planet starbase }
## push_scope = fleet
alias[effect:random_fleet_in_orbit] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { megastructure planet starbase }
## push_scope = fleet
alias[effect:ordered_fleet_in_orbit] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { megastructure planet starbase }
## push_scope = fleet
alias[effect:every_fleet_in_orbit] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country galactic_object }
## push_scope = fleet
alias[effect:random_orbital_station] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country galactic_object }
## push_scope = fleet
alias[effect:ordered_orbital_station] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country galactic_object }
## push_scope = fleet
alias[effect:every_orbital_station] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_galcom_member] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_galcom_member] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the galactic community - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_galcom_member] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}


### Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_council_member] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_council_member] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the galactic council - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_council_member] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = leader
alias[effect:ordered_owned_leader] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = leader
alias[effect:random_pool_leader] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = leader
alias[effect:ordered_pool_leader] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is recruitable for the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = leader
alias[effect:every_pool_leader] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = leader
alias[effect:random_envoy] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = leader
alias[effect:ordered_envoy] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each envoy available to the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = leader
alias[effect:every_envoy] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = megastructure
alias[effect:random_megastructure] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = megastructure
alias[effect:ordered_megastructure] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = megastructure
alias[effect:every_megastructure] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = megastructure
alias[effect:random_owned_megastructure] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = megastructure
alias[effect:ordered_owned_megastructure] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each owned megastructure - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = megastructure
alias[effect:every_owned_megastructure] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = megastructure
alias[effect:random_system_megastructure] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = megastructure
alias[effect:ordered_system_megastructure] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure in system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = megastructure
alias[effect:every_system_megastructure] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { federation }
## push_scope = country
alias[effect:random_member] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { federation }
## push_scope = country
alias[effect:ordered_member] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { federation }
## push_scope = country
alias[effect:every_member] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { federation }
## push_scope = country
alias[effect:random_associate] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { federation }
## push_scope = country
alias[effect:ordered_associate] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each associate member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { federation }
## push_scope = country
alias[effect:every_associate] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = planet
alias[effect:ordered_system_planet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = planet
alias[effect:random_system_colony] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = planet
alias[effect:ordered_system_colony] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each colony in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = planet
alias[effect:every_system_colony] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = planet
alias[effect:ordered_planet_within_border] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = planet
alias[effect:random_owned_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = planet
alias[effect:ordered_owned_planet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}


### Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = planet
alias[effect:every_owned_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = planet
alias[effect:random_controlled_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}


### Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = planet
alias[effect:ordered_controlled_planet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = planet
alias[effect:every_controlled_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = planet
alias[effect:random_galaxy_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = planet
alias[effect:ordered_galaxy_planet] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = planet
alias[effect:every_galaxy_planet] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = deposit
alias[effect:ordered_deposit] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = planet
alias[effect:ordered_moon] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet country pop_faction sector }
## push_scope = pop
alias[effect:ordered_owned_pop] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each pop that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { species }
## push_scope = pop
alias[effect:random_species_pop] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each pop that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { species }
## push_scope = pop
alias[effect:ordered_species_pop] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each pop that belongs to this species; warning: resource-intensive! - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { species }
## push_scope = pop
alias[effect:every_species_pop] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = pop_faction
alias[effect:ordered_pop_faction] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = sector
alias[effect:random_galaxy_sector] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = sector
alias[effect:ordered_galaxy_sector] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all sectors in the game - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = sector
alias[effect:every_galaxy_sector] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = sector
alias[effect:random_owned_sector] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = sector
alias[effect:ordered_owned_sector] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned sector - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = sector
alias[effect:every_owned_sector] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country fleet }
## push_scope = ship
alias[effect:ordered_owned_ship] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}


### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country fleet }
## push_scope = ship
alias[effect:random_controlled_ship] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country fleet }
## push_scope = ship
alias[effect:ordered_controlled_ship] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country fleet }
## push_scope = ship
alias[effect:every_controlled_ship] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = ship
alias[effect:random_ship_in_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = ship
alias[effect:ordered_ship_in_system] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = ship
alias[effect:every_ship_in_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = situation
alias[effect:random_situation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = situation
alias[effect:ordered_situation] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation a country is experiencing - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = situation
alias[effect:every_situation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = situation
alias[effect:random_targeting_situation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = situation
alias[effect:ordered_targeting_situation] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation that is targeting the current planet - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = situation
alias[effect:every_targeting_situation] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = species
alias[effect:random_owned_pop_species] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = species
alias[effect:ordered_owned_pop_species] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through each species of a country's owned pops - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = species
alias[effect:every_owned_pop_species] = {
	## cardinality = 0..1
	limit = {
		alias_name[trigger] = alias_match_left[trigger]
	}
	alias_name[effect] = alias_match_left[effect]
}

### Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = species
alias[effect:random_galaxy_species] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = species
alias[effect:ordered_galaxy_species] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = species
alias[effect:every_galaxy_species] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet country }
## push_scope = species
alias[effect:random_owned_species] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet country }
## push_scope = species
alias[effect:ordered_owned_species] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet country }
## push_scope = species
alias[effect:every_owned_species] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet country }
## push_scope = species
alias[effect:random_enslaved_species] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet country }
## push_scope = species
alias[effect:ordered_enslaved_species] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet country }
## push_scope = species
alias[effect:every_enslaved_species] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = starbase
alias[effect:random_owned_starbase] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = starbase
alias[effect:ordered_owned_starbase] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned primary starbase - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = starbase
alias[effect:every_owned_starbase] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = starbase
alias[effect:random_owned_nonprimary_starbase] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = starbase
alias[effect:ordered_owned_nonprimary_starbase] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = starbase
alias[effect:every_owned_nonprimary_starbase] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = system
alias[effect:random_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = system
alias[effect:ordered_system] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = system
alias[effect:every_system] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = system
alias[effect:ordered_rim_system] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}


### Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = system
alias[effect:random_system_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = system
alias[effect:ordered_system_within_border] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = system
alias[effect:every_system_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = system
alias[effect:ordered_neighbor_system] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neigboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = system
alias[effect:random_neighbor_system_euclidean] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all a system's neigboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = system
alias[effect:ordered_neighbor_system_euclidean] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neigboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = system
alias[effect:every_neighbor_system_euclidean] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { war }
## push_scope = country
alias[effect:random_war_participant] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { war }
## push_scope = country
alias[effect:ordered_war_participant] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { war }
## push_scope = country
alias[effect:random_attacker] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { war }
## push_scope = country
alias[effect:ordered_attacker] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all attackers in the current war - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { war }
## push_scope = country
alias[effect:every_attacker] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { war }
## push_scope = country
alias[effect:random_defender] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { war }
## push_scope = country
alias[effect:ordered_defender] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all defenders in the current war - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { war }
## push_scope = country
alias[effect:every_defender] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = war
alias[effect:random_war] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = war
alias[effect:ordered_war] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all wars the country is engaged in - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = war
alias[effect:every_war] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = country
alias[effect:random_pre_ftl_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = country
alias[effect:ordered_pre_ftl_within_border] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = country
alias[effect:every_pre_ftl_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = country
alias[effect:random_observed_pre_ftl_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
	### adds weights to affect the chance a specific object is selected
	## cardinality = 0..1
	weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = country
alias[effect:ordered_observed_pre_ftl_within_border] = {
	position = int
	order_by = value_field
	## cardinality = 0..1
	inverse = bool
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = country
alias[effect:every_observed_pre_ftl_within_border] = {
	## cardinality = 0..1
	limit = { alias_name[trigger] = alias_match_left[trigger] }
	alias_name[effect] = alias_match_left[effect]
}